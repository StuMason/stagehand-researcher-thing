This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-04T09:06:33.152Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  config/
    index.js
  services/
    googleService.js
    linkedInService.js
    openaiService.js
    researchService.js
  utils/
    index.js
    logger.js
.cursorrules
.env.example
.gitignore
.repomixignore
deploy.sh
ecosystem.config.js
example-run.js
index.ts
main.ts
README.md
server.js
stagehand.config.ts
test.sh
utils.ts

================================================================
Repository Files
================================================================

================
File: src/config/index.js
================
// config/index.js
import dotenv from 'dotenv';

dotenv.config();

export const StagehandConfig = {
  env: "LOCAL",
  apiKey: process.env.BROWSERBASE_API_KEY,
  projectId: process.env.BROWSERBASE_PROJECT_ID,
  debugDom: process.env.NODE_ENV !== 'production',
  headless: process.env.NODE_ENV === 'production',
  logger: (message) => {
    if (process.env.NODE_ENV !== 'production') {
      console.log(JSON.stringify({
        timestamp: message.timestamp,
        category: message.category,
        message: message.message,
        extra: message.extra
      }, null, 2));
    }
  },
  domSettleTimeoutMs: 30000,
  enableCaching: true,
  modelName: process.env.MODEL_NAME || "gpt-4o-mini",
  modelClientOptions: {
    timeout: 30000,
    apiKey: process.env.OPENAI_API_KEY,
    maxRetries: 3
  },
  browserbaseSessionCreateParams: {
    projectId: process.env.BROWSERBASE_PROJECT_ID,
  },
  browserbaseSessionID: undefined,
};

export const serverConfig = {
  host: process.env.HOST || '127.0.0.1',
  port: process.env.PORT || 3333,
  redisUrl: process.env.REDIS_URL,
  env: process.env.NODE_ENV || 'development'
};

export const cacheConfig = {
  redis: {
    url: process.env.REDIS_URL,
    ttl: 24 * 60 * 60  // 24 hours
  },
  session: {
    persistDuration: 7 * 24 * 60 * 60 * 1000  // 7 days
  }
};

================
File: src/services/googleService.js
================
// services/googleService.js
import { debugLog } from '../utils/logger.js';

export async function searchGoogle(page, query) {
  debugLog('google:search', `Searching Google`, { query });
  
  try {
    await page.goto(`https://www.google.com/search?q=${encodeURIComponent(query)}`);
    await page.waitForLoadState('networkidle');
    
    // Handle potential cookie consent
    try {
      await page.click('button:has-text("Accept all")');
      await page.waitForLoadState('networkidle');
    } catch (e) {
      // Cookie consent might not appear
    }
    
    // Extract search results
    const results = await page.evaluate(() => {
      const links = Array.from(document.querySelectorAll('div.g a[href]'));
      return links.map(link => ({
        url: link.href,
        title: link.querySelector('h3') ? link.querySelector('h3').textContent : '',
        snippet: link.closest('div.g')?.querySelector('div.VwiC3b')?.textContent || ''
      })).filter(result => 
        result.url && 
        !result.url.includes('google.com') &&
        !result.url.includes('cached') &&
        !result.url.includes('similar') &&
        !result.url.includes('webcache.googleusercontent.com')
      );
    });
    
    debugLog('google:results', `Found search results`, { 
      count: results.length,
      firstResult: results[0]
    });

    // Add a small delay to avoid rate limiting
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    return results;
  } catch (error) {
    debugLog('google:error', 'Error performing Google search', { 
      error: error.message,
      query 
    });
    throw new Error(`Google search failed: ${error.message}`);
  }
}

export async function searchGoogleWithRetry(page, query, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await searchGoogle(page, query);
    } catch (error) {
      if (attempt === maxRetries) throw error;
      
      debugLog('google:retry', `Retrying search after error`, { 
        attempt,
        error: error.message
      });
      
      // Exponential backoff
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
    }
  }
}

================
File: src/services/linkedInService.js
================
// services/linkedInService.js
import { debugLog } from '../utils/logger.js';

export class LinkedInService {
  constructor(stagehand) {
    this.stagehand = stagehand;
    this.isLoggedIn = false;
    this.cookiesAccepted = false;
  }

  async handleCookieBanners() {
    if (this.cookiesAccepted) return;
    
    const selectors = [
      'button[action-type="ACCEPT_COOKIES"]',
      '#cookie-policy-banner button[type="submit"]',
      'button:has-text("Accept All Cookies")',
      'button:has-text("Accept")',
      '[aria-label="Accept cookies"]',
      '.cookie-banner button:has-text("Accept")'
    ];

    for (const selector of selectors) {
      try {
        await this.stagehand.page.click(selector, { timeout: 2000 });
        this.cookiesAccepted = true;
        debugLog('linkedin:cookies', 'Accepted cookies banner');
        break;
      } catch (e) {
        continue;
      }
    }
  }

  async login() {
    if (this.isLoggedIn) return;

    try {
      debugLog('linkedin:login', 'Attempting LinkedIn login');
      await this.stagehand.page.goto('https://www.linkedin.com/login');
      
      await this.handleCookieBanners();
      
      await this.stagehand.page.waitForSelector('input[name="session_key"]');
      await this.stagehand.page.fill('input[name="session_key"]', process.env.LINKEDIN_EMAIL);
      await this.stagehand.page.fill('input[name="session_password"]', process.env.LINKEDIN_PASSWORD);
      
      await Promise.all([
        this.stagehand.page.click('button[type="submit"]'),
        this.stagehand.page.waitForNavigation({ waitUntil: 'networkidle' })
      ]);
      
      const verifyLogin = await this.stagehand.page.evaluate(() => {
        return !document.querySelector('.login-form');
      });
      
      if (!verifyLogin) throw new Error('Login verification failed');

      this.isLoggedIn = true;
      
      try {
        await this.stagehand.page.click('button:has-text("Skip")', { timeout: 5000 });
      } catch (e) {
        // Ignore if prompt doesn't appear
      }

      debugLog('linkedin:login', 'LinkedIn login successful');
    } catch (error) {
      debugLog('linkedin:login-error', 'LinkedIn login failed', { error: error.message });
      throw error;
    }
  }

  async extractContactInfo() {
    try {
      let contactInfo = await this.stagehand.page.evaluate(() => {
        const findContactText = (elements) => {
          for (const el of elements) {
            const text = el.textContent.trim();
            if (text.includes('@') || 
                text.match(/[\+\d][\d\-\(\)\s]{8,}/) || 
                text.match(/t\.me\/|telegram\.me\//) || 
                text.includes('linkedin.com/in/')) {
              return text;
            }
          }
          return null;
        };

        const possibleElements = [
          ...document.querySelectorAll('.pv-contact-info *'),
          ...document.querySelectorAll('.pv-top-card *'),
          ...document.querySelectorAll('.about-section *'),
          ...document.querySelectorAll('[data-field="email"] *'),
          ...document.querySelectorAll('[data-field="phone"] *')
        ];

        return {
          found: findContactText(possibleElements) || null,
          hasContactButton: !!document.querySelector('button:has-text("Contact info")')
        };
      });

      if (contactInfo.found) {
        debugLog('linkedin:contact', 'Found contact info on main profile', { info: contactInfo.found });
        return { contact: contactInfo.found };
      }

      if (contactInfo.hasContactButton) {
        debugLog('linkedin:contact', 'Clicking contact info button');
        await this.stagehand.page.click('button:has-text("Contact info")');
        await this.stagehand.page.waitForSelector('.pv-contact-info');

        const modalInfo = await this.stagehand.page.evaluate(() => {
          const modal = document.querySelector('.pv-contact-info');
          if (!modal) return null;

          const extractSection = (section) => {
            const items = Array.from(section.querySelectorAll('*'))
              .map(el => el.textContent.trim())
              .filter(text => text.length > 0);
            return items.join(' ');
          };

          const sections = Array.from(modal.children).map(extractSection);
          return sections.join(' ');
        });

        try {
          await this.stagehand.page.click('button[aria-label="Dismiss"]');
        } catch (e) {
          // Modal might have closed automatically
        }

        if (modalInfo) {
          debugLog('linkedin:contact', 'Found contact info in modal', { info: modalInfo });
          return { contact: modalInfo };
        }
      }

      debugLog('linkedin:contact', 'No contact information found');
      return { contact: null };
    } catch (error) {
      debugLog('linkedin:contact-error', 'Error extracting contact info', { error: error.message });
      return { contact: null };
    }
  }

  async verifyProfile(targetPerson) {
    try {
      const profileInfo = await this.stagehand.page.evaluate(() => ({
        name: document.querySelector('h1')?.textContent?.trim() || '',
        headline: document.querySelector('.text-body-medium')?.textContent?.trim() || '',
        experience: Array.from(document.querySelectorAll('.experience-section li'))
          .map(exp => exp.textContent?.trim())
          .join(' ')
      }));

      let score = 0;
      
      if (profileInfo.name.toLowerCase() === targetPerson.name.toLowerCase()) {
        score += 40;
      }

      if (targetPerson.context && 
          (profileInfo.headline + profileInfo.experience)
            .toLowerCase()
            .includes(targetPerson.context.toLowerCase())) {
        score += 30;
      }

      if (targetPerson.interests) {
        const content = (profileInfo.headline + profileInfo.experience).toLowerCase();
        const matchedInterests = targetPerson.interests.filter(interest => 
          content.includes(interest.toLowerCase())
        );
        score += (matchedInterests.length / targetPerson.interests.length) * 30;
      }

      return {
        isMatch: score >= 60,
        confidence: score,
        info: profileInfo
      };
    } catch (error) {
      debugLog('linkedin:verify-error', 'Failed to verify profile', { error: error.message });
      throw error;
    }
  }

  async navigateToProfile(url, targetPerson) {
    await this.login();
    debugLog('linkedin:navigate', 'Navigating to LinkedIn profile', { url });
    
    await this.stagehand.page.goto(url, {
      waitUntil: 'networkidle',
      timeout: 30000
    });
    
    await this.handleCookieBanners();
    await this.stagehand.page.waitForLoadState('networkidle');
    
    const isProfilePage = await this.stagehand.page.evaluate(() => {
      return window.location.href.includes('/in/');
    });
    
    if (!isProfilePage) {
      throw new Error('Failed to load profile page');
    }

    if (targetPerson) {
      const verification = await this.verifyProfile(targetPerson);
      if (!verification.isMatch) {
        throw new Error('Profile does not match target person');
      }
    }
    
    debugLog('linkedin:navigate', 'Successfully loaded LinkedIn profile');
  }
}

================
File: src/services/openaiService.js
================
// services/openaiService.js
import OpenAI from 'openai';
import { debugLog } from '../utils/logger.js';

console.log('Initializing OpenAI client with config:', {
  hasApiKey: !!process.env.OPENAI_API_KEY,
  keyLength: process.env.OPENAI_API_KEY?.length
});

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  timeout: 30000, // 30 seconds timeout
  maxRetries: 3,
  fetch: (url, init) => {
    console.log('Making OpenAI request:', {
      url,
      method: init.method,
      headers: init.headers,
      bodyLength: init.body?.length
    });
    return fetch(url, {
      ...init,
      signal: AbortSignal.timeout(30000) // 30 second timeout
    });
  }
});

export async function makeGPTCall(messages, temperature = 0.7, maxRetries = 3) {
  console.log('Starting GPT call with config:', {
    messagesCount: messages.length,
    temperature,
    maxRetries,
    lastMessagePreview: messages[messages.length - 1]?.content.substring(0, 100)
  });

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`Attempt ${attempt}/${maxRetries} - Making request`);

      const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages,
        temperature,
        max_tokens: 1500,
        presence_penalty: 0.1,
        frequency_penalty: 0.1
      });

      console.log('Request successful:', {
        responseStatus: 'success',
        choicesLength: response.choices?.length
      });

      return response.choices[0].message.content;

    } catch (error) {
      console.error('OpenAI request failed:', {
        attempt,
        errorName: error.name,
        errorMessage: error.message,
        errorCode: error.code,
        errorType: error.type,
        cause: error.cause,
        stack: error.stack?.split('\n')
      });

      if (error.message.includes('Connection error')) {
        // Try to make a test request to check network
        try {
          console.log('Testing network connection...');
          const testResponse = await fetch('https://api.openai.com/v1/models');
          console.log('Network test result:', {
            status: testResponse.status,
            ok: testResponse.ok
          });
        } catch (netError) {
          console.error('Network test failed:', netError);
        }
      }

      if (attempt === maxRetries) {
        throw error;
      }

      const delay = Math.min(1000 * Math.pow(2, attempt), 10000);
      console.log(`Retrying in ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

================
File: src/services/researchService.js
================
// services/researchService.js
import { debugLog } from "../utils/logger.js";
import { LinkedInService } from "./linkedInService.js";
import { searchGoogle } from "./googleService.js";
import { makeGPTCall } from "./openaiService.js";
import { parseAction } from "../utils/index.js";

export async function conductResearch(stagehand, profile) {
  debugLog("research:start", "Starting research process", { profile });
  const linkedIn = new LinkedInService(stagehand);
  let searchResults = [];
  let contactInformation = null;
  let exploredPages = new Set();
  let discoveredInfo = [];

  // Initialize with broad search
  const searchQueries = [
    `${profile.name} ${profile.context}`,
    `${profile.name} portfolio`,
    `${profile.name} projects`,
    `${profile.name} blog`,
    `${profile.name} achievements`
  ];

  for (const query of searchQueries) {
    const results = await searchGoogle(stagehand.page, query);
    searchResults.push(...results);
  }

  // Deduplicate search results
  searchResults = Array.from(new Set(searchResults.map(r => r.url))).map(url => 
    searchResults.find(r => r.url === url)
  );

  debugLog("research:links", "Found initial links", { 
    count: searchResults.length,
    urls: searchResults.map(r => r.url)
  });

  // Explore each discovered link
  for (const result of searchResults) {
    if (exploredPages.has(result.url)) continue;
    
    try {
      debugLog("research:explore", "Exploring link", { url: result.url });
      
      if (result.url.includes('linkedin.com')) {
        try {
          await linkedIn.navigateToProfile(result.url, profile);
          const contactInfo = await linkedIn.extractContactInfo();
          if (contactInfo.contact) {
            contactInformation = contactInfo.contact;
          }
        } catch (e) {
          debugLog("research:linkedin-skip", "Skipping LinkedIn profile", { error: e.message });
          continue;
        }
      } else {
        await stagehand.page.goto(result.url, { 
          waitUntil: 'networkidle',
          timeout: 30000
        });

        // Extract relevant information from the page
        const pageInfo = await stagehand.page.extract({
          instruction: `Extract professional information about ${profile.name} including:
            - Current and past roles
            - Projects and achievements
            - Skills and expertise
            - Writing style and personality traits
            - Professional interests
            Only extract information that clearly relates to ${profile.name}`,
          schema: z.object({
            content: z.string(),
            confidence: z.number()
          }),
          useTextExtract: true
        });

        if (pageInfo?.content && pageInfo.confidence > 0.6) {
          discoveredInfo.push({
            source: result.url,
            content: pageInfo.content,
            confidence: pageInfo.confidence
          });
        }
      }

      exploredPages.add(result.url);
      
    } catch (error) {
      debugLog("research:explore-error", "Error exploring link", { 
        url: result.url,
        error: error.message
      });
      continue;
    }
  }

  // Synthesize discovered information into a biography
  const synthesisPrompt = `Based on these research findings:
  ${JSON.stringify(discoveredInfo, null, 2)}

  Create a well-written, professional biography for a recruitment context. The bio should:
  1. Start with a compelling personal summary
  2. Highlight key professional achievements and experience
  3. Showcase their unique skills and expertise
  4. Include relevant personal touches that make them stand out
  5. End with their current focus and interests
  
  Write in a warm, professional tone that would make the person feel understood and appreciated.
  Focus on what makes them unique and interesting to talk to.
  Include specific details and examples where available.
  
  Structure the response as a JSON object with:
  - bio: The main biography text
  - keyPoints: Array of notable talking points for outreach
  - personalTouches: Array of personal interests or unique aspects
  - currentFocus: Their current professional focus
  - suggestedApproach: How to best approach them based on their online presence`;

  const synthesis = await makeGPTCall([{ 
    role: "user", 
    content: synthesisPrompt 
  }], 0.7);

  return {
    profile: JSON.parse(synthesis),
    contactInfo: {
      email: contactInformation?.email || null,
      phone: contactInformation?.phone || null,
      social: contactInformation?.social || []
    },
    sources: Array.from(exploredPages),
    confidence: discoveredInfo.reduce((acc, info) => acc + info.confidence, 0) / discoveredInfo.length || 0.5
  };
}

================
File: src/utils/index.js
================
import { z } from 'zod';
import { debugLog } from './logger.js';

export const parseAction = (actionText) => {
  debugLog("action:parse", "Parsing action text", { actionText });
  try {
    if (actionText.includes("SEARCH")) {
      const query = actionText.match(/SEARCH: (.*)/)[1];
      return { type: "search", query };
    }
    if (actionText.includes("NAVIGATE")) {
      const url = actionText.match(/NAVIGATE: (.*)/)[1];
      return { type: "navigate", url };
    }
    if (actionText.includes("EXTRACT")) {
      const instruction = actionText.match(/EXTRACT: (.*)/)[1];
      return { type: "extract", instruction };
    }
    if (actionText.includes("OBSERVE")) {
      const instruction = actionText.match(/OBSERVE: (.*)/)[1];
      return { type: "observe", instruction };
    }
    if (actionText.includes("CONCLUDE")) {
      return { type: "conclude" };
    }
    return null;
  } catch (error) {
    debugLog("action:parse-error", "Failed to parse action", {
      error: error.message,
    });
    return null;
  }
};



export const ProfileSchema = z.object({
  name: z.string().min(1),
  context: z.string().optional(),
  interests: z.array(z.string()).optional(),
});

================
File: src/utils/logger.js
================
export const debugLog = (category, message, auxiliary = null) => {
  const logLine = {
    timestamp: new Date().toISOString(),
    category,
    message,
    auxiliary: auxiliary && Object.fromEntries(
      Object.entries(auxiliary).map(([k, v]) => [k, {value: v, type: typeof v}])
    )
  };
  console.log(JSON.stringify(logLine));
};

================
File: .cursorrules
================
# Stagehand Project

This is a project that uses Stagehand, which amplifies Playwright with `act`, `extract`, and `observe` added to the Page class.

`Stagehand` is a class that provides config, a `StagehandPage` object via `stagehand.page`, and a `StagehandContext` object via `stagehand.context`.

`Page` is a class that extends the Playwright `Page` class and adds `act`, `extract`, and `observe` methods.
`Context` is a class that extends the Playwright `BrowserContext` class.

Use the following rules to write code for this project.

- When writing Playwright code, wrap it with Stagehand `act`
- When writing code that needs to extract data from the page, use Stagehand `extract`
- When writing code that needs to observe the page, use Stagehand `observe`

## Initialize

```typescript
import { Stagehand } from "@browserbasehq/stagehand";
import StagehandConfig from "./stagehand.config";

const stagehand = new Stagehand(StagehandConfig);
await stagehand.init();

const page = stagehand.page; // Playwright Page with act, extract, and observe methods
const context = stagehand.context; // Playwright BrowserContext
```

## Act

For example, if you are writing Playwright code, wrap it with Stagehand `act` like this:

```typescript
try {
  await page.locator('button[name="Sign in"]').click();
} catch (error) {
  await page.act({
    action: "click the sign in button",
  });
}
```

Act `action` should be as atomic and specific as possible, i.e. "Click the sign in button" or "Type 'hello' into the search input". Avoid actions that are too broad, i.e. "Order me pizza" or "Send an email to Paul asking him to call me". Actions work best for Playwright code that is vulnerable to unexpected DOM changes.

When using `act`, write Playwright code FIRST, then wrap it with a try-catch block where the catch block is `act`.

## Extract

If you are writing code that needs to extract data from the page, use Stagehand `extract` like this:

```typescript
const data = await page.extract({
  instruction: "extract the sign in button text",
  schema: z.object({
    text: z.string(),
  }),
  useTextExtract: true,
});
```

`schema` is a Zod schema that describes the data you want to extract. To extract an array, make sure to pass in a single object that contains the array, as follows:

```typescript
const data = await page.extract({
  instruction: "extract the text inside all buttons",
  schema: z.object({
    text: z.array(z.string()),
  }),
});
```

Set `useTextExtract` to `true` for better results.

## Observe

If you are writing code that needs to observe the page, use Stagehand `observe` like this:

```typescript
const data = await page.observe({
  instruction: "observe the page",
});
```

This returns a list of XPaths and descriptions of the data you want to extract as `{ selector: string; description: string }[]`.

================
File: .env.example
================
BROWSERBASE_PROJECT_ID="YOUR_BROWSERBASE_PROJECT_ID"
BROWSERBASE_API_KEY="YOUR_BROWSERBASE_API_KEY"
OPENAI_API_KEY="THIS_IS_OPTIONAL_WITH_ANTHROPIC_KEY"
ANTHROPIC_API_KEY="THIS_IS_OPTIONAL_WITH_OPENAI_KEY"

================
File: .gitignore
================
.env
node_modules
tmp
downloads
.DS_Store
dist

================
File: .repomixignore
================
tsconfig.json
package.json
package-lock.json

================
File: deploy.sh
================
cd $FORGE_SITE_PATH
npm install
npm run build
pm2 reload browser-service || pm2 start server.js --name browser-service

================
File: ecosystem.config.js
================
export default {
    apps: [{
      name: 'browser-service',
      script: 'server.js',
      exec_mode: 'fork',
      instances: 1,
      autorestart: true,
      watch: false,
      max_memory_restart: '1G',
      env: {
        NODE_ENV: 'production',
      }
    }]
  }

================
File: example-run.js
================
// example-usage.js
import { Stagehand } from "@browserbasehq/stagehand";
import { StagehandConfig } from './config/index.js';
import { LinkedInService } from './services/linkedInService.js';
import { searchGoogleWithRetry } from './services/googleService.js';
import { makeGPTCall, promptTemplates } from './services/openaiService.js';
import { debugLog } from './utils/index.js';

async function runExample() {
  // Initialize Stagehand
  const stagehand = new Stagehand(StagehandConfig);
  await stagehand.init();

  try {
    // Example profile to research
    const profile = {
      name: "Emi Laughton",
      context: "Head of Marketing",
      interests: ["brand strategy"]
    };

    // 1. Start with Google search
    console.log("Starting Google search...");
    const searchQuery = `${profile.name} ${profile.context} linkedin`;
    const searchResults = await searchGoogleWithRetry(stagehand.page, searchQuery);
    
    // Find LinkedIn profile URL from search results
    const linkedInUrl = searchResults.find(result => 
      result.url.includes('linkedin.com/in/'))?.url;

    if (linkedInUrl) {
      // 2. Initialize LinkedIn service and navigate to profile
      console.log("LinkedIn profile found, extracting information...");
      const linkedIn = new LinkedInService(stagehand);
      
      try {
        await linkedIn.navigateToProfile(linkedInUrl, profile);
        
        // 3. Extract contact information
        const contactInfo = await linkedIn.extractContactInfo();
        console.log("Contact information:", contactInfo);

        // 4. Use GPT to analyze findings
        const research = {
          linkedInProfile: linkedInUrl,
          contactInfo: contactInfo.contact,
          searchResults: searchResults
        };

        const analysis = await makeGPTCall([{
          role: "user",
          content: promptTemplates.synthesizeFindings(research, contactInfo.contact)
        }]);

        console.log("\nResearch Analysis:");
        console.log(analysis);

      } catch (error) {
        if (error.message === 'Profile does not match target person') {
          console.log("Found LinkedIn profile was not the correct person");
        } else {
          throw error;
        }
      }
    } else {
      console.log("No LinkedIn profile found in search results");
    }

  } catch (error) {
    console.error("Error during research:", error);
  } finally {
    await stagehand.close();
  }
}

// Run the example
runExample().catch(console.error);

================
File: index.ts
================
/**
 * ðŸ¤˜ Welcome to Stagehand!
 *
 * You probably DON'T NEED TO BE IN THIS FILE
 *
 * You're probably instead looking for the main() function in main.ts
 *
 * This is run when you do npm run start; it just calls main()
 *
 */

import { Stagehand } from "@browserbasehq/stagehand";
import StagehandConfig from "./stagehand.config.js";
import chalk from "chalk";
import { main } from "./main.js";
import boxen from "boxen";

async function run() {
  const stagehand = new Stagehand({
    ...StagehandConfig,
  });
  await stagehand.init();

  if (StagehandConfig.env === "BROWSERBASE" && stagehand.browserbaseSessionID) {
    console.log(
      boxen(
        `View this session live in your browser: \n${chalk.blue(
          `https://browserbase.com/sessions/${stagehand.browserbaseSessionID}`
        )}`,
        {
          title: "Browserbase",
          padding: 1,
          margin: 3,
        }
      )
    );
  }

  const page = stagehand.page;
  const context = stagehand.context;
  await main({
    page,
    context,
    stagehand,
  });
  await stagehand.close();
  console.log(
    `\nðŸ¤˜ Thanks for using Stagehand! Create an issue if you have any feedback: ${chalk.blue(
      "https://github.com/browserbase/stagehand/issues/new"
    )}\n`
  );
}

run();

================
File: main.ts
================
/**
 * ðŸ¤˜ Welcome to Stagehand!
 *
 * TO RUN THIS PROJECT:
 * ```
 * npm install
 * npm run start
 * ```
 *
 * To edit config, see `stagehand.config.ts`
 *
 * In this quickstart, we'll be automating a browser session to show you the power of Playwright and Stagehand's AI features.
 *
 * 1. Go to https://docs.browserbase.com/
 * 2. Use `extract` to find information about the quickstart
 * 3. Use `observe` to find the links under the 'Guides' section
 * 4. Use Playwright to click the first link. If it fails, use `act` to gracefully fallback to Stagehand AI.
 */

import { Page, BrowserContext, Stagehand } from "@browserbasehq/stagehand";
import { z } from "zod";
import chalk from "chalk";
import boxen from "boxen";
import dotenv from "dotenv";

dotenv.config();

export async function main({
  page,
  context,
  stagehand,
}: {
  page: Page; // Playwright Page with act, extract, and observe methods
  context: BrowserContext; // Playwright BrowserContext
  stagehand: Stagehand; // Stagehand instance
}) {
  console.log(
    [
      `ðŸ¤˜ ${chalk.yellow("Welcome to Stagehand!")}`,
      "",
      "Stagehand is a tool that allows you to automate browser interactions.",
      "Watch as this demo automatically performs the following steps:",
      "",
      `ðŸ“ Step 1: Stagehand will auto-navigate to ${chalk.blue(
        "https://docs.browserbase.com/"
      )}`,
      `ðŸ“ Step 2: Stagehand will use AI to ${chalk.green(
        "extract"
      )} information about the quickstart`,
      `ðŸ“ Step 3: Stagehand will use AI to ${chalk.green(
        "observe"
      )} and identify links in the 'Guides' section`,
      `ðŸ“ Step 4: Stagehand will attempt to click the first link using Playwright, with ${chalk.green(
        "act"
      )} as an AI fallback`,
    ].join("\n")
  );

  //   You can use the `page` instance to write any Playwright code
  //   For more info: https://playwright.dev/docs/pom
  await page.goto("https://docs.browserbase.com/");

  const description = await page.extract({
    instruction: "extract the title, description, and link of the quickstart",
    // Zod is a schema validation library similar to Pydantic in Python
    // For more information on Zod, visit: https://zod.dev/
    schema: z.object({
      title: z.string(),
      link: z.string(),
      description: z.string(),
    }),
  });
  announce(
    `The ${chalk.bgYellow(description.title)} is at: ${chalk.bgYellow(
      chalk.blue(description.link)
    )}` +
      `\n\n${chalk.bgYellow(description.description)}` +
      `\n\n${chalk.gray(JSON.stringify(description, null, 2))}`,
    "Extract"
  );

  const observeResult = await page.observe({
    instruction: "Find the links under the 'Guides' section",
  });
  announce(
    `${chalk.green("Observe:")} We can click:\n${observeResult
      .map(
        (r) => `"${chalk.yellow(r.description)}" -> ${chalk.gray(r.selector)}`
      )
      .join("\n")}`,
    "Observe"
  );

  //   In the event that your Playwright code fails, you can use the `act` method to
  //   let Stagehand AI take over and complete the action.
  try {
    throw new Error(
      "Comment out line 118 in index.ts to run the base Playwright code!"
    );

    // Wait for search button and click it
    const quickStartSelector = `#content-area > div.relative.mt-8.prose.prose-gray.dark\:prose-invert > div > a:nth-child(1)`;
    await page.waitForSelector(quickStartSelector);
    await page.locator(quickStartSelector).click();
    await page.waitForLoadState("networkidle");
    announce(
      `Clicked the quickstart link using base Playwright code. ${chalk.yellow(
        "Uncomment line 118 in index.ts to have Stagehand take over!"
      )}`
    );
  } catch (e) {
    if (!(e instanceof Error)) {
      throw e;
    }
    announce(
      `${chalk.red(
        "Looks like an error occurred running Playwright. Let's have Stagehand take over!"
      )} \n${chalk.gray(e.message)}`,
      "Playwright"
    );

    const actResult = await page.act({
      action: "Click the link to the quickstart",
    });
    announce(
      `${chalk.green(
        "Clicked the quickstart link using Stagehand AI fallback."
      )} \n${chalk.gray(actResult)}`,
      "Act"
    );
  }

  //   Close the browser
  await stagehand.close();

  console.log(
    [
      "To recap, here are the steps we took:",
      `1. We went to ${chalk.blue("https://docs.browserbase.com/")}`,
      `---`,
      `2. We used ${chalk.green(
        "extract"
      )} to find information about the quickstart`,
      `The ${chalk.bgYellow(description.title)} is at: ${chalk.bgYellow(
        chalk.blue(description.link)
      )}` +
        `\n\n${chalk.bgYellow(description.description)}` +
        `\n\n${chalk.gray(JSON.stringify(description, null, 2))}`,
      `---`,
      `3. We used ${chalk.green(
        "observe"
      )} to find the links under the 'Guides' section and got the following results:`,
      `\nWe could have clicked:\n${observeResult
        .map(
          (r) => `"${chalk.yellow(r.description)}" -> ${chalk.gray(r.selector)}`
        )
        .join("\n")}`,
      `---`,
      `4. We used Playwright to click the first link. If it failed, we used ${chalk.green(
        "act"
      )} to gracefully fallback to Stagehand AI.`,
    ].join("\n\n")
  );
}

function announce(message: string, title?: string) {
  console.log(
    boxen(message, {
      padding: 1,
      margin: 3,
      title: title || "Stagehand",
    })
  );
}

================
File: README.md
================
# ðŸ¤˜ Welcome to Stagehand!

Hey! This is a project built with [Stagehand](https://github.com/browserbase/stagehand).

You can build your own web agent using: `npx create-browser-app`!

## Setting the Stage

Stagehand is an SDK for automating browsers. It's built on top of [Playwright](https://playwright.dev/) and provides a higher-level API for better debugging and AI fail-safes.

## Curtain Call

Get ready for a show-stopping development experience. Just run:

```bash
npm install && npm start
```

## What's Next?

### Add your API keys

Required API keys/environment variables are in the `.env.example` file. Copy it to `.env` and add your API keys.

```bash
cp .env.example .env && nano .env # Add your API keys to .env
```

### Custom .cursorrules

We have custom .cursorrules for this project. It'll help quite a bit with writing Stagehand easily.

### Run on Browserbase

To run on Browserbase, add your API keys to .env and change `env: "LOCAL"` to `env: "BROWSERBASE"` in [stagehand.config.ts](stagehand.config.ts).

### Use Anthropic Claude 3.5 Sonnet

1. Add your API key to .env
2. Change `modelName: "gpt-4o"` to `modelName: "claude-3-5-sonnet-latest"` in [stagehand.config.ts](stagehand.config.ts)
3. Change `modelClientOptions: { apiKey: process.env.OPENAI_API_KEY }` to `modelClientOptions: { apiKey: process.env.ANTHROPIC_API_KEY }` in [stagehand.config.ts](stagehand.config.ts)

================
File: server.js
================
// server.js
import { StagehandConfig, serverConfig } from "./src/config/index.js";
import express from "express";
import { Stagehand } from "@browserbasehq/stagehand";
import Queue from "bull";
import rateLimit from "express-rate-limit";
import { z } from "zod";
import pkg from "@bull-monitor/express";
import rootPkg from "@bull-monitor/root/dist/bull-adapter.js";
import { debugLog } from "./src/utils/logger.js";
import { ProfileSchema } from "./src/utils/index.js";
import LRUCache from "lru-cache";
import { performance } from "perf_hooks";

const { BullMonitorExpress } = pkg;
const { BullAdapter } = rootPkg;

// Results cache configuration
const resultsCache = new LRUCache({
  max: 500, // Maximum number of items
  ttl: 1000 * 60 * 60, // 1 hour TTL
  updateAgeOnGet: true
});

// Initialize Express
const app = express();
app.use(express.json());

// Enhanced rate limiting with IP-based tracking
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
  keyGenerator: (req) => req.headers['x-forwarded-for'] || req.ip,
  handler: (req, res) => {
    res.status(429).json({
      error: "Too many requests",
      retryAfter: Math.ceil(req.rateLimit.resetTime / 1000)
    });
  }
});

app.use("/research", limiter);

// Initialize Bull Queue with retry strategy
const researchQueue = new Queue("research-queue", serverConfig.redisUrl, {
  defaultJobOptions: {
    timeout: 1800000, // 30 minute timeout
    attempts: 3,
    backoff: {
      type: "exponential",
      delay: 2000,
    },
    removeOnComplete: 100,
    removeOnFail: 100,
  },
});

// Setup Bull Monitor
async function setupMonitor() {
  const monitor = new BullMonitorExpress({
    queues: [new BullAdapter(researchQueue)],
    metrics: {
      collectInterval: 5000,
      maxMetrics: 100
    }
  });
  await monitor.init();
  app.use("/monitor", monitor.router);
}

setupMonitor().catch(console.error);

// Research job processor with enhanced error handling
researchQueue.process(async (job) => {
  const startTime = performance.now();
  let stagehand = null;
  
  try {
    stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();
    
    job.progress(10);
    debugLog("research:start", "Starting research process", { profile: job.data });

    // Profile validation with observation
    const isValidProfile = await verifyProfile(stagehand, job.data);
    if (!isValidProfile) {
      throw new Error("Unable to verify profile authenticity");
    }
    job.progress(30);

    // Conduct research with text extraction
    const results = await conductResearch(stagehand, job.data);
    job.progress(90);

    // Cache successful results
    const cacheKey = JSON.stringify(job.data);
    resultsCache.set(cacheKey, results);

    const duration = performance.now() - startTime;
    debugLog("research:complete", "Research completed successfully", {
      duration,
      profile: job.data
    });

    job.progress(100);
    return results;

  } catch (error) {
    debugLog("research:error", "Error in research process", {
      error: error.message,
      stack: error.stack,
      attempt: job.attemptsMade
    });

    // Handle specific error types
    if (error.message.includes("Navigation timeout")) {
      throw new Error("Navigation timeout - will retry automatically");
    }
    
    throw error;

  } finally {
    if (stagehand) {
      await stagehand.close().catch(console.error);
    }
  }
});

// Profile verification helper
async function verifyProfile(stagehand, profile) {
  try {
    // First navigate to a search page
    await stagehand.page.goto('https://www.google.com');
    
    // Search for the profile
    await stagehand.page.act({
      action: `search for "${profile.name} ${profile.context}"`,
      variables: { name: profile.name, context: profile.context }
    });

    // Wait for results
    await stagehand.page.waitForLoadState('networkidle');

    const observations = await stagehand.page.observe({
      instruction: `Find elements that mention ${profile.name} and their role/context "${profile.context}"`,
      returnAction: true,
      onlyVisible: true // Only look at visible elements
    });

    if (!observations || observations.length === 0) {
      debugLog("verify:warning", "No observations found", { profile });
      return true; // Continue with research if no observations
    }

    const nameMatch = observations.some(obs => 
      obs.description.toLowerCase().includes(profile.name.toLowerCase())
    );

    const contextMatch = observations.some(obs => 
      obs.description.toLowerCase().includes(profile.context.toLowerCase())
    );

    debugLog("verify:result", "Profile verification complete", {
      nameMatch,
      contextMatch,
      observationsCount: observations.length
    });

    return nameMatch || contextMatch; // Return true if either matches

  } catch (error) {
    debugLog("verify:error", "Error verifying profile", { 
      error: error.message,
      stack: error.stack
    });
    return true; // Continue with research on error
  }
}

// Enhanced research function with text extraction
const researchSchema = z.object({
  contactInfo: z.object({
    email: z.string().optional(),
    phone: z.string().optional(),
    social: z.array(z.string()).optional()
  }),
  professionalInfo: z.object({
    currentRole: z.string(),
    company: z.string().optional(),
    experience: z.array(z.string()).optional(),
    skills: z.array(z.string()).optional()
  }),
  confidence: z.number().describe('Confidence score between 0 and 1')
});

async function conductResearch(stagehand, profile) {
  const extractResult = await stagehand.page.extract({
    instruction: `Extract professional information for ${profile.name} including:
    - Contact info (email, phone, social profiles)
    - Current role and company
    - Professional experience
    - Key skills
    Rate confidence between 0 (low) and 1 (high)`,
    schema: researchSchema,
    useTextExtract: true
  });

  return {
    ...extractResult,
    searchTimestamp: new Date().toISOString()
  };
}
// Express routes with caching
app.post("/research", async (req, res) => {
  try {
    const profile = ProfileSchema.parse(req.body);
    const cacheKey = JSON.stringify(profile);

    // Check cache first
    const cached = resultsCache.get(cacheKey);
    if (cached) {
      return res.status(200).json({
        ...cached,
        cached: true
      });
    }

    const job = await researchQueue.add(profile, {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 2000
      }
    });

    res.status(202).json({
      jobId: job.id,
      status: "processing",
      statusUrl: `/research/${job.id}`,
      estimatedTime: "30-60 seconds"
    });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ 
        error: "Invalid input",
        details: error.errors
      });
    }
    res.status(400).json({ error: error.message });
  }
});

app.get("/research/:jobId", async (req, res) => {
  try {
    const job = await researchQueue.getJob(req.params.jobId);
    if (!job) {
      return res.status(404).json({ error: "Job not found" });
    }

    const state = await job.getState();
    const progress = job.progress();

    res.json({
      jobId: job.id,
      status: state,
      progress: progress,
      result: job.returnvalue,
      error: job.failedReason,
      timestamp: {
        created: job.timestamp,
        started: job.processedOn,
        finished: job.finishedOn
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Queue monitoring and cleanup
researchQueue.on("stalled", async (job) => {
  debugLog("queue:stalled", `Job ${job.id} stalled`, {
    jobData: job.data,
    timestamp: new Date().toISOString()
  });
  await job.moveToFailed({ message: "Job stalled" });
});

// Add regular cleanup jobs
const cleanupInterval = setInterval(async () => {
  try {
    await researchQueue.clean(7 * 24 * 3600 * 1000, "completed");
    await researchQueue.clean(7 * 24 * 3600 * 1000, "failed");
    
    // Clean old cache entries
    resultsCache.purgeStale();
  } catch (error) {
    debugLog("cleanup:error", "Error during cleanup", { error });
  }
}, 24 * 3600 * 1000);

// Error handling middleware
app.use((err, req, res, next) => {
  debugLog("server:error", "Unhandled error", { 
    error: err.message,
    stack: err.stack
  });
  
  res.status(500).json({
    error: "Internal server error",
    message: serverConfig.env === "development" ? err.message : undefined
  });
});

// Start server
const server = app.listen(serverConfig.port, serverConfig.host, () => {
  console.log(`Research server running on ${serverConfig.host}:${serverConfig.port}`);
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  clearInterval(cleanupInterval);
  await researchQueue.close();
  server.close();
});

================
File: stagehand.config.ts
================
import type { ConstructorParams, LogLine } from "@browserbasehq/stagehand";
import dotenv from "dotenv";

dotenv.config();

const StagehandConfig: ConstructorParams = {
  env: "LOCAL",
  apiKey: process.env.BROWSERBASE_API_KEY /* API key for authentication */,
  projectId: process.env.BROWSERBASE_PROJECT_ID /* Project identifier */,
  debugDom: true /* Enable DOM debugging features */,
  headless: true /* Run browser in headless mode */,
  logger: (message: LogLine) =>
    console.log(logLineToString(message)) /* Custom logging function */,
  domSettleTimeoutMs: 30_000 /* Timeout for DOM to settle in milliseconds */,
  browserbaseSessionCreateParams: {
    projectId: process.env.BROWSERBASE_PROJECT_ID!,
  },
  enableCaching: true /* Enable caching functionality */,
  browserbaseSessionID:
    undefined /* Session ID for resuming Browserbase sessions */,
  modelName: "gpt-4o" /* Name of the model to use */,
	modelClientOptions: {
    apiKey: process.env.OPENAI_API_KEY,
  } /* Configuration options for the model client */,
};

export default StagehandConfig;

/**
 * Custom logging function that you can use to filter logs.
 *
 * General pattern here is that `message` will always be unique with no params
 * Any param you would put in a log is in `auxiliary`.
 *
 * For example, an error log looks like this:
 *
 * ```
 * {
 *   category: "error",
 *   message: "Some specific error occurred",
 *   auxiliary: {
 *     message: { value: "Error message", type: "string" },
 *     trace: { value: "Error trace", type: "string" }
 *   }
 * }
 * ```
 *
 * You can then use `logLineToString` to filter for a specific log pattern like
 *
 * ```
 * if (logLine.message === "Some specific error occurred") {
 *   console.log(logLineToString(logLine));
 * }
 * ```
 */
export function logLineToString(logLine: LogLine): string {
  // If you want more detail, set this to false. However, this will make the logs
  // more verbose and harder to read.
  const HIDE_AUXILIARY = true;

  try {
    const timestamp = logLine.timestamp || new Date().toISOString();
    if (logLine.auxiliary?.error) {
      return `${timestamp}::[stagehand:${logLine.category}] ${logLine.message}\n ${logLine.auxiliary.error.value}\n ${logLine.auxiliary.trace.value}`;
    }

    // If we want to hide auxiliary information, we don't add it to the log
    return `${timestamp}::[stagehand:${logLine.category}] ${logLine.message} ${
      logLine.auxiliary && !HIDE_AUXILIARY
        ? JSON.stringify(logLine.auxiliary)
        : ""
    }`;
  } catch (error) {
    console.error(`Error logging line:`, error);
    return "error logging line";
  }
}

================
File: test.sh
================
curl -X POST http://localhost:3333/browser \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://stuartmason.co.uk",
    "action": "click the about page link",
    "extract": "get all the content from the page"
}'


curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Iggy Hammick",
    "context": "Designer, founder of dark blue"
  }'

curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Ben Lipscombe",
    "context": "UK Based PPC Specialist"
  }'

  curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Ali Gallop",
    "context": "Video Producer, founder of theres this place"
  }'

  curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Daniel Ruffles",
    "context": "UK based brand and design expert"
  }'


  curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Stu Mason",
    "context": "UK based web developer"
  }'


    curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Emi Laughton",
    "context": "Aviva Marketing Lead"
  }'

================
File: utils.ts
================
import boxen from "boxen";
import { z } from "zod";
export function announce(message: string, title?: string) {
  console.log(
    boxen(message, {
      padding: 1,
      margin: 3,
      title: title || "Stagehand",
    })
  );
}

/**
 * Get an environment variable and throw an error if it's not found
 * @param name - The name of the environment variable
 * @returns The value of the environment variable
 */
export function getEnvVar(name: string, required = true): string | undefined {
  const value = process.env[name];
  if (!value && required) {
    throw new Error(`${name} not found in environment variables`);
  }
  return value;
}

/**
 * Validate a Zod schema against some data
 * @param schema - The Zod schema to validate against
 * @param data - The data to validate
 * @returns Whether the data is valid against the schema
 */
export function validateZodSchema(schema: z.ZodTypeAny, data: unknown) {
  try {
    schema.parse(data);
    return true;
  } catch {
    return false;
  }
}
