This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-29T10:01:41.985Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

================================================================
Directory Structure
================================================================
.cursorrules
.env.example
.gitignore
.repomixignore
index.ts
main.ts
README.md
server.js
stagehand.config.ts
utils.ts

================================================================
Files
================================================================

================
File: .cursorrules
================
# Stagehand Project

This is a project that uses Stagehand, which amplifies Playwright with `act`, `extract`, and `observe` added to the Page class.

`Stagehand` is a class that provides config, a `StagehandPage` object via `stagehand.page`, and a `StagehandContext` object via `stagehand.context`.

`Page` is a class that extends the Playwright `Page` class and adds `act`, `extract`, and `observe` methods.
`Context` is a class that extends the Playwright `BrowserContext` class.

Use the following rules to write code for this project.

- When writing Playwright code, wrap it with Stagehand `act`
- When writing code that needs to extract data from the page, use Stagehand `extract`
- When writing code that needs to observe the page, use Stagehand `observe`

## Initialize

```typescript
import { Stagehand } from "@browserbasehq/stagehand";
import StagehandConfig from "./stagehand.config";

const stagehand = new Stagehand(StagehandConfig);
await stagehand.init();

const page = stagehand.page; // Playwright Page with act, extract, and observe methods
const context = stagehand.context; // Playwright BrowserContext
```

## Act

For example, if you are writing Playwright code, wrap it with Stagehand `act` like this:

```typescript
try {
  await page.locator('button[name="Sign in"]').click();
} catch (error) {
  await page.act({
    action: "click the sign in button",
  });
}
```

Act `action` should be as atomic and specific as possible, i.e. "Click the sign in button" or "Type 'hello' into the search input". Avoid actions that are too broad, i.e. "Order me pizza" or "Send an email to Paul asking him to call me". Actions work best for Playwright code that is vulnerable to unexpected DOM changes.

When using `act`, write Playwright code FIRST, then wrap it with a try-catch block where the catch block is `act`.

## Extract

If you are writing code that needs to extract data from the page, use Stagehand `extract` like this:

```typescript
const data = await page.extract({
  instruction: "extract the sign in button text",
  schema: z.object({
    text: z.string(),
  }),
  useTextExtract: true,
});
```

`schema` is a Zod schema that describes the data you want to extract. To extract an array, make sure to pass in a single object that contains the array, as follows:

```typescript
const data = await page.extract({
  instruction: "extract the text inside all buttons",
  schema: z.object({
    text: z.array(z.string()),
  }),
});
```

Set `useTextExtract` to `true` for better results.

## Observe

If you are writing code that needs to observe the page, use Stagehand `observe` like this:

```typescript
const data = await page.observe({
  instruction: "observe the page",
});
```

This returns a list of XPaths and descriptions of the data you want to extract as `{ selector: string; description: string }[]`.

================
File: .env.example
================
BROWSERBASE_PROJECT_ID="YOUR_BROWSERBASE_PROJECT_ID"
BROWSERBASE_API_KEY="YOUR_BROWSERBASE_API_KEY"
OPENAI_API_KEY="THIS_IS_OPTIONAL_WITH_ANTHROPIC_KEY"
ANTHROPIC_API_KEY="THIS_IS_OPTIONAL_WITH_OPENAI_KEY"

================
File: .gitignore
================
.env
node_modules
tmp
downloads
.DS_Store
dist

================
File: .repomixignore
================
tsconfig.json
package.json
package-lock.json

================
File: index.ts
================
/**
 * 🤘 Welcome to Stagehand!
 *
 * You probably DON'T NEED TO BE IN THIS FILE
 *
 * You're probably instead looking for the main() function in main.ts
 *
 * This is run when you do npm run start; it just calls main()
 *
 */

import { Stagehand } from "@browserbasehq/stagehand";
import StagehandConfig from "./stagehand.config.js";
import chalk from "chalk";
import { main } from "./main.js";
import boxen from "boxen";

async function run() {
  const stagehand = new Stagehand({
    ...StagehandConfig,
  });
  await stagehand.init();

  if (StagehandConfig.env === "BROWSERBASE" && stagehand.browserbaseSessionID) {
    console.log(
      boxen(
        `View this session live in your browser: \n${chalk.blue(
          `https://browserbase.com/sessions/${stagehand.browserbaseSessionID}`
        )}`,
        {
          title: "Browserbase",
          padding: 1,
          margin: 3,
        }
      )
    );
  }

  const page = stagehand.page;
  const context = stagehand.context;
  await main({
    page,
    context,
    stagehand,
  });
  await stagehand.close();
  console.log(
    `\n🤘 Thanks for using Stagehand! Create an issue if you have any feedback: ${chalk.blue(
      "https://github.com/browserbase/stagehand/issues/new"
    )}\n`
  );
}

run();

================
File: main.ts
================
/**
 * 🤘 Welcome to Stagehand!
 *
 * TO RUN THIS PROJECT:
 * ```
 * npm install
 * npm run start
 * ```
 *
 * To edit config, see `stagehand.config.ts`
 *
 * In this quickstart, we'll be automating a browser session to show you the power of Playwright and Stagehand's AI features.
 *
 * 1. Go to https://docs.browserbase.com/
 * 2. Use `extract` to find information about the quickstart
 * 3. Use `observe` to find the links under the 'Guides' section
 * 4. Use Playwright to click the first link. If it fails, use `act` to gracefully fallback to Stagehand AI.
 */

import { Page, BrowserContext, Stagehand } from "@browserbasehq/stagehand";
import { z } from "zod";
import chalk from "chalk";
import boxen from "boxen";
import dotenv from "dotenv";

dotenv.config();

export async function main({
  page,
  context,
  stagehand,
}: {
  page: Page; // Playwright Page with act, extract, and observe methods
  context: BrowserContext; // Playwright BrowserContext
  stagehand: Stagehand; // Stagehand instance
}) {
  console.log(
    [
      `🤘 ${chalk.yellow("Welcome to Stagehand!")}`,
      "",
      "Stagehand is a tool that allows you to automate browser interactions.",
      "Watch as this demo automatically performs the following steps:",
      "",
      `📍 Step 1: Stagehand will auto-navigate to ${chalk.blue(
        "https://docs.browserbase.com/"
      )}`,
      `📍 Step 2: Stagehand will use AI to ${chalk.green(
        "extract"
      )} information about the quickstart`,
      `📍 Step 3: Stagehand will use AI to ${chalk.green(
        "observe"
      )} and identify links in the 'Guides' section`,
      `📍 Step 4: Stagehand will attempt to click the first link using Playwright, with ${chalk.green(
        "act"
      )} as an AI fallback`,
    ].join("\n")
  );

  //   You can use the `page` instance to write any Playwright code
  //   For more info: https://playwright.dev/docs/pom
  await page.goto("https://docs.browserbase.com/");

  const description = await page.extract({
    instruction: "extract the title, description, and link of the quickstart",
    // Zod is a schema validation library similar to Pydantic in Python
    // For more information on Zod, visit: https://zod.dev/
    schema: z.object({
      title: z.string(),
      link: z.string(),
      description: z.string(),
    }),
  });
  announce(
    `The ${chalk.bgYellow(description.title)} is at: ${chalk.bgYellow(
      chalk.blue(description.link)
    )}` +
      `\n\n${chalk.bgYellow(description.description)}` +
      `\n\n${chalk.gray(JSON.stringify(description, null, 2))}`,
    "Extract"
  );

  const observeResult = await page.observe({
    instruction: "Find the links under the 'Guides' section",
  });
  announce(
    `${chalk.green("Observe:")} We can click:\n${observeResult
      .map(
        (r) => `"${chalk.yellow(r.description)}" -> ${chalk.gray(r.selector)}`
      )
      .join("\n")}`,
    "Observe"
  );

  //   In the event that your Playwright code fails, you can use the `act` method to
  //   let Stagehand AI take over and complete the action.
  try {
    throw new Error(
      "Comment out line 118 in index.ts to run the base Playwright code!"
    );

    // Wait for search button and click it
    const quickStartSelector = `#content-area > div.relative.mt-8.prose.prose-gray.dark\:prose-invert > div > a:nth-child(1)`;
    await page.waitForSelector(quickStartSelector);
    await page.locator(quickStartSelector).click();
    await page.waitForLoadState("networkidle");
    announce(
      `Clicked the quickstart link using base Playwright code. ${chalk.yellow(
        "Uncomment line 118 in index.ts to have Stagehand take over!"
      )}`
    );
  } catch (e) {
    if (!(e instanceof Error)) {
      throw e;
    }
    announce(
      `${chalk.red(
        "Looks like an error occurred running Playwright. Let's have Stagehand take over!"
      )} \n${chalk.gray(e.message)}`,
      "Playwright"
    );

    const actResult = await page.act({
      action: "Click the link to the quickstart",
    });
    announce(
      `${chalk.green(
        "Clicked the quickstart link using Stagehand AI fallback."
      )} \n${chalk.gray(actResult)}`,
      "Act"
    );
  }

  //   Close the browser
  await stagehand.close();

  console.log(
    [
      "To recap, here are the steps we took:",
      `1. We went to ${chalk.blue("https://docs.browserbase.com/")}`,
      `---`,
      `2. We used ${chalk.green(
        "extract"
      )} to find information about the quickstart`,
      `The ${chalk.bgYellow(description.title)} is at: ${chalk.bgYellow(
        chalk.blue(description.link)
      )}` +
        `\n\n${chalk.bgYellow(description.description)}` +
        `\n\n${chalk.gray(JSON.stringify(description, null, 2))}`,
      `---`,
      `3. We used ${chalk.green(
        "observe"
      )} to find the links under the 'Guides' section and got the following results:`,
      `\nWe could have clicked:\n${observeResult
        .map(
          (r) => `"${chalk.yellow(r.description)}" -> ${chalk.gray(r.selector)}`
        )
        .join("\n")}`,
      `---`,
      `4. We used Playwright to click the first link. If it failed, we used ${chalk.green(
        "act"
      )} to gracefully fallback to Stagehand AI.`,
    ].join("\n\n")
  );
}

function announce(message: string, title?: string) {
  console.log(
    boxen(message, {
      padding: 1,
      margin: 3,
      title: title || "Stagehand",
    })
  );
}

================
File: README.md
================
# 🤘 Welcome to Stagehand!

Hey! This is a project built with [Stagehand](https://github.com/browserbase/stagehand).

You can build your own web agent using: `npx create-browser-app`!

## Setting the Stage

Stagehand is an SDK for automating browsers. It's built on top of [Playwright](https://playwright.dev/) and provides a higher-level API for better debugging and AI fail-safes.

## Curtain Call

Get ready for a show-stopping development experience. Just run:

```bash
npm install && npm start
```

## What's Next?

### Add your API keys

Required API keys/environment variables are in the `.env.example` file. Copy it to `.env` and add your API keys.

```bash
cp .env.example .env && nano .env # Add your API keys to .env
```

### Custom .cursorrules

We have custom .cursorrules for this project. It'll help quite a bit with writing Stagehand easily.

### Run on Browserbase

To run on Browserbase, add your API keys to .env and change `env: "LOCAL"` to `env: "BROWSERBASE"` in [stagehand.config.ts](stagehand.config.ts).

### Use Anthropic Claude 3.5 Sonnet

1. Add your API key to .env
2. Change `modelName: "gpt-4o"` to `modelName: "claude-3-5-sonnet-latest"` in [stagehand.config.ts](stagehand.config.ts)
3. Change `modelClientOptions: { apiKey: process.env.OPENAI_API_KEY }` to `modelClientOptions: { apiKey: process.env.ANTHROPIC_API_KEY }` in [stagehand.config.ts](stagehand.config.ts)

================
File: server.js
================
import express from 'express';
import pkg from '@browserbasehq/stagehand';
const { main } = pkg;
import { z } from 'zod';
import dotenv from 'dotenv';

dotenv.config();

const app = express();
app.use(express.json());

// Basic health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'ok' });
});

// Main browser automation endpoint
app.post('/browser', async (req, res) => {
  try {
    // Create a handler function that will process the request
    const handler = async ({ page, context, stagehand }) => {
      try {
        // Navigate to the URL
        if (req.body.url) {
          await page.goto(req.body.url);
        }
        
        // Perform actions if specified
        if (req.body.action) {
          const actResult = await page.act({
            action: req.body.action
          });
          console.log('Action result:', actResult);
        }
        
        // Extract data if specified
        if (req.body.extract) {
          const data = await page.extract({
            instruction: req.body.extract,
            schema: z.object({
              result: z.string()
            })
          });
          return data;
        } else if (req.body.observe) {
          // Observe elements if specified
          const elements = await page.observe({
            instruction: req.body.observe
          });
          return { elements };
        } else {
          // If no extraction requested, just return success
          return { status: 'success' };
        }
      } finally {
        await stagehand.close();
      }
    };

    // Execute the handler using Stagehand's main function
    const result = await main(handler);
    res.json(result);
    
  } catch (error) {
    console.error('Error:', error);
    res.status(500).json({ 
      error: error.message,
      stack: process.env.NODE_ENV === 'development' ? error.stack : undefined
    });
  }
});

const PORT = process.env.PORT || 3000;
app.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

================
File: stagehand.config.ts
================
import type { ConstructorParams, LogLine } from "@browserbasehq/stagehand";
import dotenv from "dotenv";

dotenv.config();

const StagehandConfig: ConstructorParams = {
  env: "LOCAL",
  apiKey: process.env.BROWSERBASE_API_KEY /* API key for authentication */,
  projectId: process.env.BROWSERBASE_PROJECT_ID /* Project identifier */,
  debugDom: true /* Enable DOM debugging features */,
  headless: true /* Run browser in headless mode */,
  logger: (message: LogLine) =>
    console.log(logLineToString(message)) /* Custom logging function */,
  domSettleTimeoutMs: 30_000 /* Timeout for DOM to settle in milliseconds */,
  browserbaseSessionCreateParams: {
    projectId: process.env.BROWSERBASE_PROJECT_ID!,
  },
  enableCaching: true /* Enable caching functionality */,
  browserbaseSessionID:
    undefined /* Session ID for resuming Browserbase sessions */,
  modelName: "gpt-4o" /* Name of the model to use */,
	modelClientOptions: {
    apiKey: process.env.OPENAI_API_KEY,
  } /* Configuration options for the model client */,
};

export default StagehandConfig;

/**
 * Custom logging function that you can use to filter logs.
 *
 * General pattern here is that `message` will always be unique with no params
 * Any param you would put in a log is in `auxiliary`.
 *
 * For example, an error log looks like this:
 *
 * ```
 * {
 *   category: "error",
 *   message: "Some specific error occurred",
 *   auxiliary: {
 *     message: { value: "Error message", type: "string" },
 *     trace: { value: "Error trace", type: "string" }
 *   }
 * }
 * ```
 *
 * You can then use `logLineToString` to filter for a specific log pattern like
 *
 * ```
 * if (logLine.message === "Some specific error occurred") {
 *   console.log(logLineToString(logLine));
 * }
 * ```
 */
export function logLineToString(logLine: LogLine): string {
  // If you want more detail, set this to false. However, this will make the logs
  // more verbose and harder to read.
  const HIDE_AUXILIARY = true;

  try {
    const timestamp = logLine.timestamp || new Date().toISOString();
    if (logLine.auxiliary?.error) {
      return `${timestamp}::[stagehand:${logLine.category}] ${logLine.message}\n ${logLine.auxiliary.error.value}\n ${logLine.auxiliary.trace.value}`;
    }

    // If we want to hide auxiliary information, we don't add it to the log
    return `${timestamp}::[stagehand:${logLine.category}] ${logLine.message} ${
      logLine.auxiliary && !HIDE_AUXILIARY
        ? JSON.stringify(logLine.auxiliary)
        : ""
    }`;
  } catch (error) {
    console.error(`Error logging line:`, error);
    return "error logging line";
  }
}

================
File: utils.ts
================
import boxen from "boxen";
import { z } from "zod";
export function announce(message: string, title?: string) {
  console.log(
    boxen(message, {
      padding: 1,
      margin: 3,
      title: title || "Stagehand",
    })
  );
}

/**
 * Get an environment variable and throw an error if it's not found
 * @param name - The name of the environment variable
 * @returns The value of the environment variable
 */
export function getEnvVar(name: string, required = true): string | undefined {
  const value = process.env[name];
  if (!value && required) {
    throw new Error(`${name} not found in environment variables`);
  }
  return value;
}

/**
 * Validate a Zod schema against some data
 * @param schema - The Zod schema to validate against
 * @param data - The data to validate
 * @returns Whether the data is valid against the schema
 */
export function validateZodSchema(schema: z.ZodTypeAny, data: unknown) {
  try {
    schema.parse(data);
    return true;
  } catch {
    return false;
  }
}
