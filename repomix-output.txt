This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-02-04T09:48:19.893Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  config/
    index.js
  services/
    googleService.js
    linkedInService.js
    openaiService.js
    researchService.js
  utils/
    dialogHandler.js
    index.js
    logger.js
.cursorrules
.env.example
.gitignore
.repomixignore
deploy.sh
ecosystem.config.js
example-run.js
index.ts
main.ts
README.md
server.js
stagehand.config.ts
test.sh
utils.ts

================================================================
Repository Files
================================================================

================
File: src/config/index.js
================
// config/index.js
import dotenv from 'dotenv';

dotenv.config();

export const StagehandConfig = {
  env: "LOCAL",
  apiKey: process.env.BROWSERBASE_API_KEY,
  projectId: process.env.BROWSERBASE_PROJECT_ID,
  debugDom: process.env.NODE_ENV !== 'production',
  headless: process.env.NODE_ENV === 'production',
  logger: (message) => {
    if (process.env.NODE_ENV !== 'production') {
      console.log(JSON.stringify({
        timestamp: message.timestamp,
        category: message.category,
        message: message.message,
        extra: message.extra
      }, null, 2));
    }
  },
  domSettleTimeoutMs: 30000,
  enableCaching: true,
  modelName: process.env.MODEL_NAME || "gpt-4o-mini",
  modelClientOptions: {
    timeout: 30000,
    apiKey: process.env.OPENAI_API_KEY,
    maxRetries: 3
  },
  browserbaseSessionCreateParams: {
    projectId: process.env.BROWSERBASE_PROJECT_ID,
  },
  browserbaseSessionID: undefined,
};

export const serverConfig = {
  host: process.env.HOST || '127.0.0.1',
  port: process.env.PORT || 3333,
  redisUrl: process.env.REDIS_URL,
  env: process.env.NODE_ENV || 'development'
};

export const cacheConfig = {
  redis: {
    url: process.env.REDIS_URL,
    ttl: 24 * 60 * 60  // 24 hours
  },
  session: {
    persistDuration: 7 * 24 * 60 * 60 * 1000  // 7 days
  }
};

================
File: src/services/googleService.js
================
// services/googleService.js
import { debugLog } from '../utils/logger.js';

export async function searchGoogle(page, query) {
  debugLog('google:search', `Searching Google`, { query });
  
  try {
    await page.goto(`https://www.google.com/search?q=${encodeURIComponent(query)}`);
    await page.waitForLoadState('networkidle');
    
    // Handle potential cookie consent
    try {
      await page.click('button:has-text("Accept all")');
      await page.waitForLoadState('networkidle');
    } catch (e) {
      // Cookie consent might not appear
    }
    
    // Extract search results
    const results = await page.evaluate(() => {
      const links = Array.from(document.querySelectorAll('div.g a[href]'));
      return links.map(link => ({
        url: link.href,
        title: link.querySelector('h3') ? link.querySelector('h3').textContent : '',
        snippet: link.closest('div.g')?.querySelector('div.VwiC3b')?.textContent || ''
      })).filter(result => 
        result.url && 
        !result.url.includes('google.com') &&
        !result.url.includes('cached') &&
        !result.url.includes('similar') &&
        !result.url.includes('webcache.googleusercontent.com')
      );
    });
    
    debugLog('google:results', `Found search results`, { 
      count: results.length,
      firstResult: results[0]
    });

    // Add a small delay to avoid rate limiting
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    return results;
  } catch (error) {
    debugLog('google:error', 'Error performing Google search', { 
      error: error.message,
      query 
    });
    throw new Error(`Google search failed: ${error.message}`);
  }
}

export async function searchGoogleWithRetry(page, query, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await searchGoogle(page, query);
    } catch (error) {
      if (attempt === maxRetries) throw error;
      
      debugLog('google:retry', `Retrying search after error`, { 
        attempt,
        error: error.message
      });
      
      // Exponential backoff
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
    }
  }
}

================
File: src/services/linkedInService.js
================
// src/services/linkedInService.js
import { debugLog } from '../utils/logger.js';
import { z } from 'zod';

export class LinkedInService {
  constructor(stagehand) {
    this.stagehand = stagehand;
    this.isLoggedIn = false;
    this.cookiesAccepted = false;
  }

  async waitForNavigationSafely(timeoutMs = 30000) {
    try {
      await Promise.race([
        this.stagehand.page.waitForLoadState('networkidle', { timeout: timeoutMs }),
        new Promise(resolve => setTimeout(resolve, timeoutMs))
      ]);
    } catch (error) {
      debugLog('linkedin:navigation', 'Navigation timeout - continuing anyway', {
        error: error.message
      });
    }
  }

  async handleCookieBanners() {
    if (this.cookiesAccepted) return;
    
    const selectors = [
      'button[action-type="ACCEPT_COOKIES"]',
      '#cookie-policy-banner button[type="submit"]',
      'button:has-text("Accept All Cookies")',
      'button:has-text("Accept")',
      '[aria-label="Accept cookies"]',
      '.cookie-banner button:has-text("Accept")'
    ];

    for (const selector of selectors) {
      try {
        await this.stagehand.page.click(selector, { timeout: 2000 });
        this.cookiesAccepted = true;
        debugLog('linkedin:cookies', 'Accepted cookies banner');
        break;
      } catch (e) {
        continue;
      }
    }
  }

  async login() {
    if (this.isLoggedIn) return;

    try {
      debugLog('linkedin:login', 'Attempting LinkedIn login');
      await this.stagehand.page.goto('https://www.linkedin.com/login', {
        waitUntil: 'domcontentloaded',
        timeout: 30000
      });
      
      await this.waitForNavigationSafely();
      await this.handleCookieBanners();
      
      // Wait for login form
      await this.stagehand.page.waitForSelector('input[name="session_key"]', { timeout: 10000 });
      
      // Fill login form
      await this.stagehand.page.fill('input[name="session_key"]', process.env.LINKEDIN_EMAIL);
      await this.stagehand.page.fill('input[name="session_password"]', process.env.LINKEDIN_PASSWORD);
      
      // Submit and wait for navigation
      await Promise.all([
        this.stagehand.page.click('button[type="submit"]'),
        this.stagehand.page.waitForNavigation({ waitUntil: 'domcontentloaded' })
      ]);

      await this.waitForNavigationSafely();
      
      // Verify login
      const isLoggedIn = await this.stagehand.page.evaluate(() => {
        return !document.querySelector('.login-form');
      }).catch(() => false);
      
      if (!isLoggedIn) {
        throw new Error('Login verification failed');
      }

      this.isLoggedIn = true;
      
      // Handle skip button if present
      try {
        await this.stagehand.page.click('button:has-text("Skip")', { timeout: 5000 });
      } catch (e) {
        // Ignore if prompt doesn't appear
      }

      debugLog('linkedin:login', 'LinkedIn login successful');
    } catch (error) {
      debugLog('linkedin:login-error', 'LinkedIn login failed', { error: error.message });
      throw error;
    }
  }

  async extractContactInfo() {
    try {
      await this.waitForNavigationSafely();

      const contactInfo = await this.stagehand.page.extract({
        instruction: "Extract the person's contact information including email, phone, social media links, and other contact methods",
        schema: z.object({
          email: z.string().nullable(),
          phone: z.string().nullable(),
          social: z.array(z.string()).default([]),
          other: z.string().nullable()
        })
      });

      debugLog('linkedin:contact', 'Extracted contact information', { info: contactInfo });
      return { contact: contactInfo };

    } catch (error) {
      debugLog('linkedin:contact-error', 'Error extracting contact info', { error: error.message });
      return { contact: null };
    }
  }

  async navigateToProfile(url, targetPerson) {
    try {
      await this.login();
      debugLog('linkedin:navigate', 'Navigating to LinkedIn profile', { url });
      
      // Clean up the URL to ensure it's a proper LinkedIn profile URL
      const profileUrl = url.split('?')[0]; // Remove query parameters
      
      await this.stagehand.page.goto(profileUrl, {
        waitUntil: 'domcontentloaded',
        timeout: 30000
      });
      
      await this.waitForNavigationSafely();
      await this.handleCookieBanners();
      
      // Verify we're on a profile page
      const isProfilePage = await this.stagehand.page.evaluate(() => {
        return window.location.href.includes('/in/');
      }).catch(() => false);
      
      if (!isProfilePage) {
        throw new Error('Failed to load profile page');
      }

      // Extract profile information for verification
      const profileInfo = await this.stagehand.page.extract({
        instruction: `Extract basic profile information to verify this is ${targetPerson.name}'s profile`,
        schema: z.object({
          name: z.string(),
          headline: z.string().nullable(),
          summary: z.string().nullable()
        })
      });

      // Simple name matching
      const namesMatch = profileInfo.name.toLowerCase().includes(targetPerson.name.toLowerCase()) ||
                        targetPerson.name.toLowerCase().includes(profileInfo.name.toLowerCase());

      if (!namesMatch) {
        throw new Error('Profile does not match target person');
      }
      
      debugLog('linkedin:navigate', 'Successfully loaded LinkedIn profile');
      return true;

    } catch (error) {
      debugLog('linkedin:navigate-error', 'Failed to navigate to profile', { 
        error: error.message,
        url 
      });
      throw error;
    }
  }
}

================
File: src/services/openaiService.js
================
// services/openaiService.js
import OpenAI from 'openai';
import { debugLog } from '../utils/logger.js';

console.log('Initializing OpenAI client with config:', {
  hasApiKey: !!process.env.OPENAI_API_KEY,
  keyLength: process.env.OPENAI_API_KEY?.length
});

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  timeout: 30000, // 30 seconds timeout
  maxRetries: 3,
  fetch: (url, init) => {
    console.log('Making OpenAI request:', {
      url,
      method: init.method,
      headers: init.headers,
      bodyLength: init.body?.length
    });
    return fetch(url, {
      ...init,
      signal: AbortSignal.timeout(30000) // 30 second timeout
    });
  }
});

export async function makeGPTCall(messages, temperature = 0.7, maxRetries = 3) {
  console.log('Starting GPT call with config:', {
    messagesCount: messages.length,
    temperature,
    maxRetries,
    lastMessagePreview: messages[messages.length - 1]?.content.substring(0, 100)
  });

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`Attempt ${attempt}/${maxRetries} - Making request`);

      const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages,
        temperature,
        max_tokens: 1500,
        presence_penalty: 0.1,
        frequency_penalty: 0.1
      });

      console.log('Request successful:', {
        responseStatus: 'success',
        choicesLength: response.choices?.length
      });

      return response.choices[0].message.content;

    } catch (error) {
      console.error('OpenAI request failed:', {
        attempt,
        errorName: error.name,
        errorMessage: error.message,
        errorCode: error.code,
        errorType: error.type,
        cause: error.cause,
        stack: error.stack?.split('\n')
      });

      if (error.message.includes('Connection error')) {
        // Try to make a test request to check network
        try {
          console.log('Testing network connection...');
          const testResponse = await fetch('https://api.openai.com/v1/models');
          console.log('Network test result:', {
            status: testResponse.status,
            ok: testResponse.ok
          });
        } catch (netError) {
          console.error('Network test failed:', netError);
        }
      }

      if (attempt === maxRetries) {
        throw error;
      }

      const delay = Math.min(1000 * Math.pow(2, attempt), 10000);
      console.log(`Retrying in ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

================
File: src/services/researchService.js
================
// src/services/conductResearch.js
import { LinkedInService } from "./linkedInService.js";
import { searchGoogle } from "./googleService.js";
import { makeGPTCall } from "./openaiService.js";
import { debugLog } from "../utils/logger.js";
import { setupDialogHandling } from "../utils/dialogHandler.js";
import { z } from "zod";

async function conductResearch(stagehand, profile) {
  debugLog("research:start", "Starting research process", { profile });
  
  // Set up dialog handling
  const clearDialogHandling = setupDialogHandling(stagehand.page);
  
  try {
    const linkedIn = new LinkedInService(stagehand);
    let searchResults = [];
    let contactInformation = null;
    let discoveredInfo = [];

    // 1. Initial broad search queries
    const searchQueries = [
      `${profile.name} ${profile.context}`, // Main search
      `${profile.name} linkedin`,           // LinkedIn profile
      `${profile.name} contact`,            // Contact information
      `${profile.name} about`,              // About/Bio pages
      `${profile.name} news`                // Recent news/mentions
    ];

    // Perform searches and collect results
    for (const query of searchQueries) {
      try {
        const results = await searchGoogle(stagehand.page, query);
        searchResults.push(...results);
        await stagehand.page.waitForTimeout(1000); // Prevent rate limiting
      } catch (error) {
        debugLog("research:search-error", `Error searching for ${query}`, { error: error.message });
      }
    }

    // Remove duplicates and sort by relevance
    searchResults = Array.from(new Set(searchResults.map(r => r.url)))
      .map(url => searchResults.find(r => r.url === url))
      .sort((a, b) => {
        // Prioritize LinkedIn and personal websites
        const aScore = a.url.includes('linkedin.com') ? 2 : 
                      (a.url.includes(profile.name.toLowerCase().replace(' ', '')) ? 1 : 0);
        const bScore = b.url.includes('linkedin.com') ? 2 : 
                      (b.url.includes(profile.name.toLowerCase().replace(' ', '')) ? 1 : 0);
        return bScore - aScore;
      });

    // 2. Process each discovered link
    for (const result of searchResults) {
      try {
        if (result.url.includes('linkedin.com/in/')) {
          // Handle LinkedIn profiles
          try {
            await linkedIn.navigateToProfile(result.url, profile);
            const contactInfo = await linkedIn.extractContactInfo();
            if (contactInfo.contact) {
              contactInformation = contactInfo.contact;
            }
          } catch (e) {
            debugLog("research:linkedin-error", "Error processing LinkedIn profile", { error: e.message });
            continue;
          }
        } else {
          // Extract information from other pages
          await stagehand.page.goto(result.url, { 
            timeout: 30000,
            waitUntil: 'domcontentloaded'
          });
          
          const pageInfo = await stagehand.page.extract({
            instruction: `Extract professional information about ${profile.name} including:
              - Current role and company
              - Professional history
              - Notable achievements
              - Areas of expertise
              - Recent activities or news
              Only include information that clearly relates to ${profile.name} and matches the context "${profile.context}"`,
            schema: z.object({
              content: z.string(),
              confidence: z.number(),
              type: z.enum(['profile', 'news', 'achievement', 'general'])
            }),
            timeout: 45000 // Longer timeout for content extraction
          });

          if (pageInfo?.content && pageInfo.confidence > 0.6) {
            discoveredInfo.push({
              source: result.url,
              content: pageInfo.content,
              type: pageInfo.type,
              confidence: pageInfo.confidence
            });
          }

          // Add delay between page visits
          await stagehand.page.waitForTimeout(1000);
        }
      } catch (error) {
        debugLog("research:explore-error", "Error exploring link", { 
          url: result.url,
          error: error.message
        });
        continue;
      }
    }

    // 3. Generate professional bio
    const bioPrompt = `Based on the following research findings:
    ${JSON.stringify(discoveredInfo, null, 2)}

    Create a professional bio for ${profile.name} that includes:
    1. A concise personal summary
    2. Current role and professional focus
    3. Key achievements and experience
    4. Areas of expertise
    5. Recent activities or news
    
    Format the response as a JSON object with:
    - bio: Main biography text (2-3 paragraphs)
    - currentRole: Their current position and company
    - expertise: Array of key areas of expertise
    - achievements: Array of notable accomplishments
    - recentActivity: Any relevant recent activity or news
    - keyPoints: Array of notable talking points for outreach
    
    Keep the tone professional and factual. Only include information that you are confident relates to the correct person based on the context "${profile.context}".`;

    const bioResponse = await makeGPTCall([{
      role: "user",
      content: bioPrompt
    }]);

    return {
      profile: JSON.parse(bioResponse),
      contactInfo: {
        email: contactInformation?.email || null,
        phone: contactInformation?.phone || null,
        social: contactInformation?.social || []
      },
      sources: Array.from(new Set(discoveredInfo.map(info => info.source))),
      confidence: discoveredInfo.reduce((acc, info) => acc + info.confidence, 0) / discoveredInfo.length || 0.5
    };

  } finally {
    // Clean up dialog handling
    clearDialogHandling();
  }
}

export default conductResearch;

================
File: src/utils/dialogHandler.js
================
// src/utils/dialogHandler.js
import { debugLog } from './logger.js';

export async function handleDialogs(page) {
  try {
    // Use StageHand's act to intelligently handle common interruptions
    await page.act({
      action: "dismiss any popup, modal, or permission dialog that might be interrupting the main content. This includes cookie notices, location permissions, newsletter signups, and other interruptions",
      skipActionCacheForThisStep: true  // Don't cache dialog handling since popups can be dynamic
    }).catch(() => {
      // If no actionable dialogs found, that's okay
      debugLog('dialog:check', 'No actionable dialogs found');
    });

  } catch (error) {
    debugLog('dialog:error', 'Error handling dialogs', { error: error.message });
  }
}

// Handle native browser dialogs (alert, confirm, prompt)
export function setupDialogHandling(page) {
  // Handle native dialogs
  page.on('dialog', async (dialog) => {
    debugLog('dialog:native', `Dismissing native dialog: ${dialog.type()}`);
    await dialog.dismiss();
  });

  // Set up a lightweight interval to check for and handle dialogs
  const intervalId = setInterval(async () => {
    await handleDialogs(page);
  }, 5000); // Check every 5 seconds

  // Return cleanup function
  return () => clearInterval(intervalId);
}

================
File: src/utils/index.js
================
import { z } from 'zod';
import { debugLog } from './logger.js';

export const parseAction = (actionText) => {
  debugLog("action:parse", "Parsing action text", { actionText });
  try {
    if (actionText.includes("SEARCH")) {
      const query = actionText.match(/SEARCH: (.*)/)[1];
      return { type: "search", query };
    }
    if (actionText.includes("NAVIGATE")) {
      const url = actionText.match(/NAVIGATE: (.*)/)[1];
      return { type: "navigate", url };
    }
    if (actionText.includes("EXTRACT")) {
      const instruction = actionText.match(/EXTRACT: (.*)/)[1];
      return { type: "extract", instruction };
    }
    if (actionText.includes("OBSERVE")) {
      const instruction = actionText.match(/OBSERVE: (.*)/)[1];
      return { type: "observe", instruction };
    }
    if (actionText.includes("CONCLUDE")) {
      return { type: "conclude" };
    }
    return null;
  } catch (error) {
    debugLog("action:parse-error", "Failed to parse action", {
      error: error.message,
    });
    return null;
  }
};



export const ProfileSchema = z.object({
  name: z.string().min(1),
  context: z.string().optional(),
  interests: z.array(z.string()).optional(),
});

================
File: src/utils/logger.js
================
export const debugLog = (category, message, auxiliary = null) => {
  const logLine = {
    timestamp: new Date().toISOString(),
    category,
    message,
    auxiliary: auxiliary && Object.fromEntries(
      Object.entries(auxiliary).map(([k, v]) => [k, {value: v, type: typeof v}])
    )
  };
  console.log(JSON.stringify(logLine));
};

================
File: .cursorrules
================
# Stagehand Project

This is a project that uses Stagehand, which amplifies Playwright with `act`, `extract`, and `observe` added to the Page class.

`Stagehand` is a class that provides config, a `StagehandPage` object via `stagehand.page`, and a `StagehandContext` object via `stagehand.context`.

`Page` is a class that extends the Playwright `Page` class and adds `act`, `extract`, and `observe` methods.
`Context` is a class that extends the Playwright `BrowserContext` class.

Use the following rules to write code for this project.

- When writing Playwright code, wrap it with Stagehand `act`
- When writing code that needs to extract data from the page, use Stagehand `extract`
- When writing code that needs to observe the page, use Stagehand `observe`

## Initialize

```typescript
import { Stagehand } from "@browserbasehq/stagehand";
import StagehandConfig from "./stagehand.config";

const stagehand = new Stagehand(StagehandConfig);
await stagehand.init();

const page = stagehand.page; // Playwright Page with act, extract, and observe methods
const context = stagehand.context; // Playwright BrowserContext
```

## Act

For example, if you are writing Playwright code, wrap it with Stagehand `act` like this:

```typescript
try {
  await page.locator('button[name="Sign in"]').click();
} catch (error) {
  await page.act({
    action: "click the sign in button",
  });
}
```

Act `action` should be as atomic and specific as possible, i.e. "Click the sign in button" or "Type 'hello' into the search input". Avoid actions that are too broad, i.e. "Order me pizza" or "Send an email to Paul asking him to call me". Actions work best for Playwright code that is vulnerable to unexpected DOM changes.

When using `act`, write Playwright code FIRST, then wrap it with a try-catch block where the catch block is `act`.

## Extract

If you are writing code that needs to extract data from the page, use Stagehand `extract` like this:

```typescript
const data = await page.extract({
  instruction: "extract the sign in button text",
  schema: z.object({
    text: z.string(),
  }),
  useTextExtract: true,
});
```

`schema` is a Zod schema that describes the data you want to extract. To extract an array, make sure to pass in a single object that contains the array, as follows:

```typescript
const data = await page.extract({
  instruction: "extract the text inside all buttons",
  schema: z.object({
    text: z.array(z.string()),
  }),
});
```

Set `useTextExtract` to `true` for better results.

## Observe

If you are writing code that needs to observe the page, use Stagehand `observe` like this:

```typescript
const data = await page.observe({
  instruction: "observe the page",
});
```

This returns a list of XPaths and descriptions of the data you want to extract as `{ selector: string; description: string }[]`.

================
File: .env.example
================
BROWSERBASE_PROJECT_ID="YOUR_BROWSERBASE_PROJECT_ID"
BROWSERBASE_API_KEY="YOUR_BROWSERBASE_API_KEY"
OPENAI_API_KEY="THIS_IS_OPTIONAL_WITH_ANTHROPIC_KEY"
ANTHROPIC_API_KEY="THIS_IS_OPTIONAL_WITH_OPENAI_KEY"

================
File: .gitignore
================
.env
node_modules
tmp
downloads
.DS_Store
dist

================
File: .repomixignore
================
tsconfig.json
package.json
package-lock.json

================
File: deploy.sh
================
cd $FORGE_SITE_PATH
npm install
npm run build
pm2 reload browser-service || pm2 start server.js --name browser-service

================
File: ecosystem.config.js
================
export default {
    apps: [{
      name: 'browser-service',
      script: 'server.js',
      exec_mode: 'fork',
      instances: 1,
      autorestart: true,
      watch: false,
      max_memory_restart: '1G',
      env: {
        NODE_ENV: 'production',
      }
    }]
  }

================
File: example-run.js
================
// example-usage.js
import { Stagehand } from "@browserbasehq/stagehand";
import { StagehandConfig } from './config/index.js';
import { LinkedInService } from './services/linkedInService.js';
import { searchGoogleWithRetry } from './services/googleService.js';
import { makeGPTCall, promptTemplates } from './services/openaiService.js';
import { debugLog } from './utils/index.js';

async function runExample() {
  // Initialize Stagehand
  const stagehand = new Stagehand(StagehandConfig);
  await stagehand.init();

  try {
    // Example profile to research
    const profile = {
      name: "Emi Laughton",
      context: "Head of Marketing",
      interests: ["brand strategy"]
    };

    // 1. Start with Google search
    console.log("Starting Google search...");
    const searchQuery = `${profile.name} ${profile.context} linkedin`;
    const searchResults = await searchGoogleWithRetry(stagehand.page, searchQuery);
    
    // Find LinkedIn profile URL from search results
    const linkedInUrl = searchResults.find(result => 
      result.url.includes('linkedin.com/in/'))?.url;

    if (linkedInUrl) {
      // 2. Initialize LinkedIn service and navigate to profile
      console.log("LinkedIn profile found, extracting information...");
      const linkedIn = new LinkedInService(stagehand);
      
      try {
        await linkedIn.navigateToProfile(linkedInUrl, profile);
        
        // 3. Extract contact information
        const contactInfo = await linkedIn.extractContactInfo();
        console.log("Contact information:", contactInfo);

        // 4. Use GPT to analyze findings
        const research = {
          linkedInProfile: linkedInUrl,
          contactInfo: contactInfo.contact,
          searchResults: searchResults
        };

        const analysis = await makeGPTCall([{
          role: "user",
          content: promptTemplates.synthesizeFindings(research, contactInfo.contact)
        }]);

        console.log("\nResearch Analysis:");
        console.log(analysis);

      } catch (error) {
        if (error.message === 'Profile does not match target person') {
          console.log("Found LinkedIn profile was not the correct person");
        } else {
          throw error;
        }
      }
    } else {
      console.log("No LinkedIn profile found in search results");
    }

  } catch (error) {
    console.error("Error during research:", error);
  } finally {
    await stagehand.close();
  }
}

// Run the example
runExample().catch(console.error);

================
File: index.ts
================
/**
 * 🤘 Welcome to Stagehand!
 *
 * You probably DON'T NEED TO BE IN THIS FILE
 *
 * You're probably instead looking for the main() function in main.ts
 *
 * This is run when you do npm run start; it just calls main()
 *
 */

import { Stagehand } from "@browserbasehq/stagehand";
import StagehandConfig from "./stagehand.config.js";
import chalk from "chalk";
import { main } from "./main.js";
import boxen from "boxen";

async function run() {
  const stagehand = new Stagehand({
    ...StagehandConfig,
  });
  await stagehand.init();

  if (StagehandConfig.env === "BROWSERBASE" && stagehand.browserbaseSessionID) {
    console.log(
      boxen(
        `View this session live in your browser: \n${chalk.blue(
          `https://browserbase.com/sessions/${stagehand.browserbaseSessionID}`
        )}`,
        {
          title: "Browserbase",
          padding: 1,
          margin: 3,
        }
      )
    );
  }

  const page = stagehand.page;
  const context = stagehand.context;
  await main({
    page,
    context,
    stagehand,
  });
  await stagehand.close();
  console.log(
    `\n🤘 Thanks for using Stagehand! Create an issue if you have any feedback: ${chalk.blue(
      "https://github.com/browserbase/stagehand/issues/new"
    )}\n`
  );
}

run();

================
File: main.ts
================
/**
 * 🤘 Welcome to Stagehand!
 *
 * TO RUN THIS PROJECT:
 * ```
 * npm install
 * npm run start
 * ```
 *
 * To edit config, see `stagehand.config.ts`
 *
 * In this quickstart, we'll be automating a browser session to show you the power of Playwright and Stagehand's AI features.
 *
 * 1. Go to https://docs.browserbase.com/
 * 2. Use `extract` to find information about the quickstart
 * 3. Use `observe` to find the links under the 'Guides' section
 * 4. Use Playwright to click the first link. If it fails, use `act` to gracefully fallback to Stagehand AI.
 */

import { Page, BrowserContext, Stagehand } from "@browserbasehq/stagehand";
import { z } from "zod";
import chalk from "chalk";
import boxen from "boxen";
import dotenv from "dotenv";

dotenv.config();

export async function main({
  page,
  context,
  stagehand,
}: {
  page: Page; // Playwright Page with act, extract, and observe methods
  context: BrowserContext; // Playwright BrowserContext
  stagehand: Stagehand; // Stagehand instance
}) {
  console.log(
    [
      `🤘 ${chalk.yellow("Welcome to Stagehand!")}`,
      "",
      "Stagehand is a tool that allows you to automate browser interactions.",
      "Watch as this demo automatically performs the following steps:",
      "",
      `📍 Step 1: Stagehand will auto-navigate to ${chalk.blue(
        "https://docs.browserbase.com/"
      )}`,
      `📍 Step 2: Stagehand will use AI to ${chalk.green(
        "extract"
      )} information about the quickstart`,
      `📍 Step 3: Stagehand will use AI to ${chalk.green(
        "observe"
      )} and identify links in the 'Guides' section`,
      `📍 Step 4: Stagehand will attempt to click the first link using Playwright, with ${chalk.green(
        "act"
      )} as an AI fallback`,
    ].join("\n")
  );

  //   You can use the `page` instance to write any Playwright code
  //   For more info: https://playwright.dev/docs/pom
  await page.goto("https://docs.browserbase.com/");

  const description = await page.extract({
    instruction: "extract the title, description, and link of the quickstart",
    // Zod is a schema validation library similar to Pydantic in Python
    // For more information on Zod, visit: https://zod.dev/
    schema: z.object({
      title: z.string(),
      link: z.string(),
      description: z.string(),
    }),
  });
  announce(
    `The ${chalk.bgYellow(description.title)} is at: ${chalk.bgYellow(
      chalk.blue(description.link)
    )}` +
      `\n\n${chalk.bgYellow(description.description)}` +
      `\n\n${chalk.gray(JSON.stringify(description, null, 2))}`,
    "Extract"
  );

  const observeResult = await page.observe({
    instruction: "Find the links under the 'Guides' section",
  });
  announce(
    `${chalk.green("Observe:")} We can click:\n${observeResult
      .map(
        (r) => `"${chalk.yellow(r.description)}" -> ${chalk.gray(r.selector)}`
      )
      .join("\n")}`,
    "Observe"
  );

  //   In the event that your Playwright code fails, you can use the `act` method to
  //   let Stagehand AI take over and complete the action.
  try {
    throw new Error(
      "Comment out line 118 in index.ts to run the base Playwright code!"
    );

    // Wait for search button and click it
    const quickStartSelector = `#content-area > div.relative.mt-8.prose.prose-gray.dark\:prose-invert > div > a:nth-child(1)`;
    await page.waitForSelector(quickStartSelector);
    await page.locator(quickStartSelector).click();
    await page.waitForLoadState("networkidle");
    announce(
      `Clicked the quickstart link using base Playwright code. ${chalk.yellow(
        "Uncomment line 118 in index.ts to have Stagehand take over!"
      )}`
    );
  } catch (e) {
    if (!(e instanceof Error)) {
      throw e;
    }
    announce(
      `${chalk.red(
        "Looks like an error occurred running Playwright. Let's have Stagehand take over!"
      )} \n${chalk.gray(e.message)}`,
      "Playwright"
    );

    const actResult = await page.act({
      action: "Click the link to the quickstart",
    });
    announce(
      `${chalk.green(
        "Clicked the quickstart link using Stagehand AI fallback."
      )} \n${chalk.gray(actResult)}`,
      "Act"
    );
  }

  //   Close the browser
  await stagehand.close();

  console.log(
    [
      "To recap, here are the steps we took:",
      `1. We went to ${chalk.blue("https://docs.browserbase.com/")}`,
      `---`,
      `2. We used ${chalk.green(
        "extract"
      )} to find information about the quickstart`,
      `The ${chalk.bgYellow(description.title)} is at: ${chalk.bgYellow(
        chalk.blue(description.link)
      )}` +
        `\n\n${chalk.bgYellow(description.description)}` +
        `\n\n${chalk.gray(JSON.stringify(description, null, 2))}`,
      `---`,
      `3. We used ${chalk.green(
        "observe"
      )} to find the links under the 'Guides' section and got the following results:`,
      `\nWe could have clicked:\n${observeResult
        .map(
          (r) => `"${chalk.yellow(r.description)}" -> ${chalk.gray(r.selector)}`
        )
        .join("\n")}`,
      `---`,
      `4. We used Playwright to click the first link. If it failed, we used ${chalk.green(
        "act"
      )} to gracefully fallback to Stagehand AI.`,
    ].join("\n\n")
  );
}

function announce(message: string, title?: string) {
  console.log(
    boxen(message, {
      padding: 1,
      margin: 3,
      title: title || "Stagehand",
    })
  );
}

================
File: README.md
================
# 🤘 Welcome to Stagehand!

Hey! This is a project built with [Stagehand](https://github.com/browserbase/stagehand).

You can build your own web agent using: `npx create-browser-app`!

## Setting the Stage

Stagehand is an SDK for automating browsers. It's built on top of [Playwright](https://playwright.dev/) and provides a higher-level API for better debugging and AI fail-safes.

## Curtain Call

Get ready for a show-stopping development experience. Just run:

```bash
npm install && npm start
```

## What's Next?

### Add your API keys

Required API keys/environment variables are in the `.env.example` file. Copy it to `.env` and add your API keys.

```bash
cp .env.example .env && nano .env # Add your API keys to .env
```

### Custom .cursorrules

We have custom .cursorrules for this project. It'll help quite a bit with writing Stagehand easily.

### Run on Browserbase

To run on Browserbase, add your API keys to .env and change `env: "LOCAL"` to `env: "BROWSERBASE"` in [stagehand.config.ts](stagehand.config.ts).

### Use Anthropic Claude 3.5 Sonnet

1. Add your API key to .env
2. Change `modelName: "gpt-4o"` to `modelName: "claude-3-5-sonnet-latest"` in [stagehand.config.ts](stagehand.config.ts)
3. Change `modelClientOptions: { apiKey: process.env.OPENAI_API_KEY }` to `modelClientOptions: { apiKey: process.env.ANTHROPIC_API_KEY }` in [stagehand.config.ts](stagehand.config.ts)

================
File: server.js
================
import express from "express";
import Queue from "bull";
import rateLimit from "express-rate-limit";
import { StagehandConfig, serverConfig } from "./src/config/index.js";
import { Stagehand } from "@browserbasehq/stagehand";
import { z } from "zod";
import { debugLog } from "./src/utils/logger.js";
import conductResearch from "./src/services/researchService.js";

// Initialize Express app
const app = express();
app.use(express.json());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000, // 15 minutes
  max: 100,
  message: { error: "Too many requests, please try again later" }
});

app.use("/research", limiter);

// Initialize research queue
const researchQueue = new Queue("research-queue", serverConfig.redisUrl, {
  defaultJobOptions: {
    timeout: 1800000, // 30 minute timeout
    attempts: 2,
    backoff: {
      type: "fixed",
      delay: 5000
    },
    removeOnComplete: 100,
    removeOnFail: 100
  }
});

// Profile validation schema
const ProfileSchema = z.object({
  name: z.string().min(1),
  context: z.string().min(1)
});

// Research job processor
researchQueue.process(async (job) => {
  const startTime = performance.now();
  let stagehand = null;
  
  try {
    stagehand = new Stagehand(StagehandConfig);
    await stagehand.init();
    
    job.progress(10);
    debugLog("research:start", "Starting research process", { profile: job.data });

    const results = await conductResearch(stagehand, job.data);
    job.progress(100);

    const duration = performance.now() - startTime;
    debugLog("research:complete", "Research completed successfully", {
      duration,
      profile: job.data
    });

    return results;

  } catch (error) {
    debugLog("research:error", "Error in research process", {
      error: error.message,
      stack: error.stack,
      attempt: job.attemptsMade
    });
    throw error;

  } finally {
    if (stagehand) {
      await stagehand.close().catch(console.error);
    }
  }
});

// POST endpoint to start research
app.post("/research", async (req, res) => {
  try {
    const profile = ProfileSchema.parse(req.body);
    
    const job = await researchQueue.add(profile, {
      attempts: 3,
      backoff: {
        type: 'exponential',
        delay: 2000
      }
    });

    res.status(202).json({
      jobId: job.id,
      status: "processing",
      statusUrl: `/research/${job.id}`,
      estimatedTime: "5-15 minutes"
    });

  } catch (error) {
    if (error instanceof z.ZodError) {
      return res.status(400).json({ 
        error: "Invalid input",
        details: error.errors
      });
    }
    res.status(400).json({ error: error.message });
  }
});

// GET endpoint to check research status
app.get("/research/:jobId", async (req, res) => {
  try {
    const job = await researchQueue.getJob(req.params.jobId);
    if (!job) {
      return res.status(404).json({ error: "Job not found" });
    }

    const state = await job.getState();
    const progress = job.progress();

    res.json({
      jobId: job.id,
      status: state,
      progress: progress,
      result: job.returnvalue,
      error: job.failedReason,
      timestamp: {
        created: job.timestamp,
        started: job.processedOn,
        finished: job.finishedOn
      }
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Graceful shutdown
process.on('SIGTERM', async () => {
  await researchQueue.close();
  server.close();
});

// Start server
const server = app.listen(serverConfig.port, serverConfig.host, () => {
  console.log(`Research server running on ${serverConfig.host}:${serverConfig.port}`);
});

================
File: stagehand.config.ts
================
import type { ConstructorParams, LogLine } from "@browserbasehq/stagehand";
import dotenv from "dotenv";

dotenv.config();

const StagehandConfig: ConstructorParams = {
  env: "LOCAL",
  apiKey: process.env.BROWSERBASE_API_KEY /* API key for authentication */,
  projectId: process.env.BROWSERBASE_PROJECT_ID /* Project identifier */,
  debugDom: true /* Enable DOM debugging features */,
  headless: true /* Run browser in headless mode */,
  logger: (message: LogLine) =>
    console.log(logLineToString(message)) /* Custom logging function */,
  domSettleTimeoutMs: 30_000 /* Timeout for DOM to settle in milliseconds */,
  browserbaseSessionCreateParams: {
    projectId: process.env.BROWSERBASE_PROJECT_ID!,
  },
  enableCaching: true /* Enable caching functionality */,
  browserbaseSessionID:
    undefined /* Session ID for resuming Browserbase sessions */,
  modelName: "gpt-4o" /* Name of the model to use */,
	modelClientOptions: {
    apiKey: process.env.OPENAI_API_KEY,
  } /* Configuration options for the model client */,
};

export default StagehandConfig;

/**
 * Custom logging function that you can use to filter logs.
 *
 * General pattern here is that `message` will always be unique with no params
 * Any param you would put in a log is in `auxiliary`.
 *
 * For example, an error log looks like this:
 *
 * ```
 * {
 *   category: "error",
 *   message: "Some specific error occurred",
 *   auxiliary: {
 *     message: { value: "Error message", type: "string" },
 *     trace: { value: "Error trace", type: "string" }
 *   }
 * }
 * ```
 *
 * You can then use `logLineToString` to filter for a specific log pattern like
 *
 * ```
 * if (logLine.message === "Some specific error occurred") {
 *   console.log(logLineToString(logLine));
 * }
 * ```
 */
export function logLineToString(logLine: LogLine): string {
  // If you want more detail, set this to false. However, this will make the logs
  // more verbose and harder to read.
  const HIDE_AUXILIARY = true;

  try {
    const timestamp = logLine.timestamp || new Date().toISOString();
    if (logLine.auxiliary?.error) {
      return `${timestamp}::[stagehand:${logLine.category}] ${logLine.message}\n ${logLine.auxiliary.error.value}\n ${logLine.auxiliary.trace.value}`;
    }

    // If we want to hide auxiliary information, we don't add it to the log
    return `${timestamp}::[stagehand:${logLine.category}] ${logLine.message} ${
      logLine.auxiliary && !HIDE_AUXILIARY
        ? JSON.stringify(logLine.auxiliary)
        : ""
    }`;
  } catch (error) {
    console.error(`Error logging line:`, error);
    return "error logging line";
  }
}

================
File: test.sh
================
curl -X POST http://localhost:3333/browser \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://stuartmason.co.uk",
    "action": "click the about page link",
    "extract": "get all the content from the page"
}'


curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Iggy Hammick",
    "context": "Designer, founder of dark blue"
  }'

curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Ben Lipscombe",
    "context": "UK Based PPC Specialist"
  }'

  curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Ali Gallop",
    "context": "Video Producer, founder of theres this place"
  }'

  curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Daniel Ruffles",
    "context": "UK based brand and design expert"
  }'


  curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Stu Mason",
    "context": "UK based web developer"
  }'


    curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Emi Laughton",
    "context": "Aviva Marketing Lead"
  }'

================
File: utils.ts
================
import boxen from "boxen";
import { z } from "zod";
export function announce(message: string, title?: string) {
  console.log(
    boxen(message, {
      padding: 1,
      margin: 3,
      title: title || "Stagehand",
    })
  );
}

/**
 * Get an environment variable and throw an error if it's not found
 * @param name - The name of the environment variable
 * @returns The value of the environment variable
 */
export function getEnvVar(name: string, required = true): string | undefined {
  const value = process.env[name];
  if (!value && required) {
    throw new Error(`${name} not found in environment variables`);
  }
  return value;
}

/**
 * Validate a Zod schema against some data
 * @param schema - The Zod schema to validate against
 * @param data - The data to validate
 * @returns Whether the data is valid against the schema
 */
export function validateZodSchema(schema: z.ZodTypeAny, data: unknown) {
  try {
    schema.parse(data);
    return true;
  } catch {
    return false;
  }
}
