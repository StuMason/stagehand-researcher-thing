This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2025-01-31T17:15:02.693Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  config/
    index.js
  services/
    googleService.js
    linkedInService.js
    openaiService.js
    researchService.js
  utils/
    index.js
    logger.js
.cursorrules
.env.example
.gitignore
.repomixignore
deploy.sh
ecosystem.config.js
example-run.js
index.ts
main.ts
README.md
server.js
stagehand.config.ts
test.sh
utils.ts

================================================================
Repository Files
================================================================

================
File: src/config/index.js
================
// config/index.js
import dotenv from 'dotenv';

dotenv.config();

export const StagehandConfig = {
  env: "LOCAL",
  apiKey: process.env.BROWSERBASE_API_KEY,
  projectId: process.env.BROWSERBASE_PROJECT_ID,
  debugDom: process.env.NODE_ENV !== 'production',
  headless: true,
  logger: (message) => {
    if (process.env.NODE_ENV !== 'production') {
      console.log(JSON.stringify({
        timestamp: message.timestamp,
        category: message.category,
        message: message.message,
        extra: message.extra
      }, null, 2));
    }
  },
  domSettleTimeoutMs: 30000,
  enableCaching: true,
  modelName: process.env.MODEL_NAME || "gpt-4o-mini",
  modelClientOptions: {
    timeout: 30000,
    apiKey: process.env.OPENAI_API_KEY,
    maxRetries: 3
  },
  browserbaseSessionCreateParams: {
    projectId: process.env.BROWSERBASE_PROJECT_ID,
  },
  browserbaseSessionID: undefined,
};

export const serverConfig = {
  host: process.env.HOST || '127.0.0.1',
  port: process.env.PORT || 3333,
  redisUrl: process.env.REDIS_URL,
  env: process.env.NODE_ENV || 'development'
};

export const cacheConfig = {
  redis: {
    url: process.env.REDIS_URL,
    ttl: 24 * 60 * 60  // 24 hours
  },
  session: {
    persistDuration: 7 * 24 * 60 * 60 * 1000  // 7 days
  }
};

================
File: src/services/googleService.js
================
// services/googleService.js
import { debugLog } from '../utils/logger.js';

export async function searchGoogle(page, query) {
  debugLog('google:search', `Searching Google`, { query });
  
  try {
    await page.goto(`https://www.google.com/search?q=${encodeURIComponent(query)}`);
    await page.waitForLoadState('networkidle');
    
    // Handle potential cookie consent
    try {
      await page.click('button:has-text("Accept all")');
      await page.waitForLoadState('networkidle');
    } catch (e) {
      // Cookie consent might not appear
    }
    
    // Extract search results
    const results = await page.evaluate(() => {
      const links = Array.from(document.querySelectorAll('div.g a[href]'));
      return links.map(link => ({
        url: link.href,
        title: link.querySelector('h3') ? link.querySelector('h3').textContent : '',
        snippet: link.closest('div.g')?.querySelector('div.VwiC3b')?.textContent || ''
      })).filter(result => 
        result.url && 
        !result.url.includes('google.com') &&
        !result.url.includes('cached') &&
        !result.url.includes('similar') &&
        !result.url.includes('webcache.googleusercontent.com')
      );
    });
    
    debugLog('google:results', `Found search results`, { 
      count: results.length,
      firstResult: results[0]
    });

    // Add a small delay to avoid rate limiting
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    return results;
  } catch (error) {
    debugLog('google:error', 'Error performing Google search', { 
      error: error.message,
      query 
    });
    throw new Error(`Google search failed: ${error.message}`);
  }
}

export async function searchGoogleWithRetry(page, query, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await searchGoogle(page, query);
    } catch (error) {
      if (attempt === maxRetries) throw error;
      
      debugLog('google:retry', `Retrying search after error`, { 
        attempt,
        error: error.message
      });
      
      // Exponential backoff
      await new Promise(resolve => setTimeout(resolve, Math.pow(2, attempt) * 1000));
    }
  }
}

================
File: src/services/linkedInService.js
================
// services/linkedInService.js
import { debugLog } from '../utils/logger.js';

export class LinkedInService {
  constructor(stagehand) {
    this.stagehand = stagehand;
    this.isLoggedIn = false;
    this.cookiesAccepted = false;
  }

  async handleCookieBanners() {
    if (this.cookiesAccepted) return;
    
    const selectors = [
      'button[action-type="ACCEPT_COOKIES"]',
      '#cookie-policy-banner button[type="submit"]',
      'button:has-text("Accept All Cookies")',
      'button:has-text("Accept")',
      '[aria-label="Accept cookies"]',
      '.cookie-banner button:has-text("Accept")'
    ];

    for (const selector of selectors) {
      try {
        await this.stagehand.page.click(selector, { timeout: 2000 });
        this.cookiesAccepted = true;
        debugLog('linkedin:cookies', 'Accepted cookies banner');
        break;
      } catch (e) {
        continue;
      }
    }
  }

  async login() {
    if (this.isLoggedIn) return;

    try {
      debugLog('linkedin:login', 'Attempting LinkedIn login');
      await this.stagehand.page.goto('https://www.linkedin.com/login');
      
      await this.handleCookieBanners();
      
      await this.stagehand.page.waitForSelector('input[name="session_key"]');
      await this.stagehand.page.fill('input[name="session_key"]', process.env.LINKEDIN_EMAIL);
      await this.stagehand.page.fill('input[name="session_password"]', process.env.LINKEDIN_PASSWORD);
      
      await Promise.all([
        this.stagehand.page.click('button[type="submit"]'),
        this.stagehand.page.waitForNavigation({ waitUntil: 'networkidle' })
      ]);
      
      const verifyLogin = await this.stagehand.page.evaluate(() => {
        return !document.querySelector('.login-form');
      });
      
      if (!verifyLogin) throw new Error('Login verification failed');

      this.isLoggedIn = true;
      
      try {
        await this.stagehand.page.click('button:has-text("Skip")', { timeout: 5000 });
      } catch (e) {
        // Ignore if prompt doesn't appear
      }

      debugLog('linkedin:login', 'LinkedIn login successful');
    } catch (error) {
      debugLog('linkedin:login-error', 'LinkedIn login failed', { error: error.message });
      throw error;
    }
  }

  async extractContactInfo() {
    try {
      let contactInfo = await this.stagehand.page.evaluate(() => {
        const findContactText = (elements) => {
          for (const el of elements) {
            const text = el.textContent.trim();
            if (text.includes('@') || 
                text.match(/[\+\d][\d\-\(\)\s]{8,}/) || 
                text.match(/t\.me\/|telegram\.me\//) || 
                text.includes('linkedin.com/in/')) {
              return text;
            }
          }
          return null;
        };

        const possibleElements = [
          ...document.querySelectorAll('.pv-contact-info *'),
          ...document.querySelectorAll('.pv-top-card *'),
          ...document.querySelectorAll('.about-section *'),
          ...document.querySelectorAll('[data-field="email"] *'),
          ...document.querySelectorAll('[data-field="phone"] *')
        ];

        return {
          found: findContactText(possibleElements) || null,
          hasContactButton: !!document.querySelector('button:has-text("Contact info")')
        };
      });

      if (contactInfo.found) {
        debugLog('linkedin:contact', 'Found contact info on main profile', { info: contactInfo.found });
        return { contact: contactInfo.found };
      }

      if (contactInfo.hasContactButton) {
        debugLog('linkedin:contact', 'Clicking contact info button');
        await this.stagehand.page.click('button:has-text("Contact info")');
        await this.stagehand.page.waitForSelector('.pv-contact-info');

        const modalInfo = await this.stagehand.page.evaluate(() => {
          const modal = document.querySelector('.pv-contact-info');
          if (!modal) return null;

          const extractSection = (section) => {
            const items = Array.from(section.querySelectorAll('*'))
              .map(el => el.textContent.trim())
              .filter(text => text.length > 0);
            return items.join(' ');
          };

          const sections = Array.from(modal.children).map(extractSection);
          return sections.join(' ');
        });

        try {
          await this.stagehand.page.click('button[aria-label="Dismiss"]');
        } catch (e) {
          // Modal might have closed automatically
        }

        if (modalInfo) {
          debugLog('linkedin:contact', 'Found contact info in modal', { info: modalInfo });
          return { contact: modalInfo };
        }
      }

      debugLog('linkedin:contact', 'No contact information found');
      return { contact: null };
    } catch (error) {
      debugLog('linkedin:contact-error', 'Error extracting contact info', { error: error.message });
      return { contact: null };
    }
  }

  async verifyProfile(targetPerson) {
    try {
      const profileInfo = await this.stagehand.page.evaluate(() => ({
        name: document.querySelector('h1')?.textContent?.trim() || '',
        headline: document.querySelector('.text-body-medium')?.textContent?.trim() || '',
        experience: Array.from(document.querySelectorAll('.experience-section li'))
          .map(exp => exp.textContent?.trim())
          .join(' ')
      }));

      let score = 0;
      
      if (profileInfo.name.toLowerCase() === targetPerson.name.toLowerCase()) {
        score += 40;
      }

      if (targetPerson.context && 
          (profileInfo.headline + profileInfo.experience)
            .toLowerCase()
            .includes(targetPerson.context.toLowerCase())) {
        score += 30;
      }

      if (targetPerson.interests) {
        const content = (profileInfo.headline + profileInfo.experience).toLowerCase();
        const matchedInterests = targetPerson.interests.filter(interest => 
          content.includes(interest.toLowerCase())
        );
        score += (matchedInterests.length / targetPerson.interests.length) * 30;
      }

      return {
        isMatch: score >= 60,
        confidence: score,
        info: profileInfo
      };
    } catch (error) {
      debugLog('linkedin:verify-error', 'Failed to verify profile', { error: error.message });
      throw error;
    }
  }

  async navigateToProfile(url, targetPerson) {
    await this.login();
    debugLog('linkedin:navigate', 'Navigating to LinkedIn profile', { url });
    
    await this.stagehand.page.goto(url, {
      waitUntil: 'networkidle',
      timeout: 30000
    });
    
    await this.handleCookieBanners();
    await this.stagehand.page.waitForLoadState('networkidle');
    
    const isProfilePage = await this.stagehand.page.evaluate(() => {
      return window.location.href.includes('/in/');
    });
    
    if (!isProfilePage) {
      throw new Error('Failed to load profile page');
    }

    if (targetPerson) {
      const verification = await this.verifyProfile(targetPerson);
      if (!verification.isMatch) {
        throw new Error('Profile does not match target person');
      }
    }
    
    debugLog('linkedin:navigate', 'Successfully loaded LinkedIn profile');
  }
}

================
File: src/services/openaiService.js
================
// services/openaiService.js
import OpenAI from 'openai';
import { debugLog } from '../utils/logger.js';

console.log('Initializing OpenAI client with config:', {
  hasApiKey: !!process.env.OPENAI_API_KEY,
  keyLength: process.env.OPENAI_API_KEY?.length
});

const openai = new OpenAI({
  apiKey: process.env.OPENAI_API_KEY,
  timeout: 30000, // 30 seconds timeout
  maxRetries: 3,
  fetch: (url, init) => {
    console.log('Making OpenAI request:', {
      url,
      method: init.method,
      headers: init.headers,
      bodyLength: init.body?.length
    });
    return fetch(url, {
      ...init,
      signal: AbortSignal.timeout(30000) // 30 second timeout
    });
  }
});

export async function makeGPTCall(messages, temperature = 0.7, maxRetries = 3) {
  console.log('Starting GPT call with config:', {
    messagesCount: messages.length,
    temperature,
    maxRetries,
    lastMessagePreview: messages[messages.length - 1]?.content.substring(0, 100)
  });

  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      console.log(`Attempt ${attempt}/${maxRetries} - Making request`);

      const response = await openai.chat.completions.create({
        model: "gpt-4o-mini",
        messages,
        temperature,
        max_tokens: 1500,
        presence_penalty: 0.1,
        frequency_penalty: 0.1
      });

      console.log('Request successful:', {
        responseStatus: 'success',
        choicesLength: response.choices?.length
      });

      return response.choices[0].message.content;

    } catch (error) {
      console.error('OpenAI request failed:', {
        attempt,
        errorName: error.name,
        errorMessage: error.message,
        errorCode: error.code,
        errorType: error.type,
        cause: error.cause,
        stack: error.stack?.split('\n')
      });

      if (error.message.includes('Connection error')) {
        // Try to make a test request to check network
        try {
          console.log('Testing network connection...');
          const testResponse = await fetch('https://api.openai.com/v1/models');
          console.log('Network test result:', {
            status: testResponse.status,
            ok: testResponse.ok
          });
        } catch (netError) {
          console.error('Network test failed:', netError);
        }
      }

      if (attempt === maxRetries) {
        throw error;
      }

      const delay = Math.min(1000 * Math.pow(2, attempt), 10000);
      console.log(`Retrying in ${delay}ms...`);
      await new Promise(resolve => setTimeout(resolve, delay));
    }
  }
}

================
File: src/services/researchService.js
================
// services/researchService.js
import { debugLog } from "../utils/logger.js";
import { LinkedInService } from "./linkedInService.js";
import { searchGoogle } from "./googleService.js";
import { makeGPTCall } from "./openaiService.js";
import { parseAction } from "../utils/index.js";
import { z } from "zod";

export async function conductResearch(stagehand, profile) {
  debugLog("research:start", "Starting research process", { profile });
  const linkedIn = new LinkedInService(stagehand);
  let searchResults = [];
  let contactInformation = null;

  const planningPrompt = `You are an advanced research assistant with access to a web browser.
You can search Google, navigate websites, and extract information.

Your goal is to research this person:
${JSON.stringify(profile, null, 2)}

You can use these commands:
- SEARCH: [query] - Search Google with this query
- NAVIGATE: [url] - Visit a webpage
- EXTRACT: [instruction] - Extract specific information
- OBSERVE: [instruction] - Analyze the current page
- CONCLUDE - End research when sufficient information is gathered

Start by planning some Google searches about this person. Consider:
1. Their name combined with their professional context
2. Their name with potential employers or organizations
3. Their name with terms like "LinkedIn", "contact info", "email", "blog", "speaker", etc.
4. Their name with any known interests or specialties

What's your research plan?`;

  debugLog("research:prompt", "Sending planning prompt to GPT", {
    prompt: planningPrompt,
  });
  const researchPlan = await makeGPTCall(
    [{ role: "user", content: planningPrompt }],
    0.5
  );
  let researchResults = { plan: researchPlan, findings: [] };

  try {
    let iteration = 0;
    const MAX_ITERATIONS = 15;
    let currentUrl = null;
    let navigationFailures = 0;

    while (iteration < MAX_ITERATIONS && navigationFailures < 3) {
      debugLog("research:iteration", `Starting iteration ${iteration}`, {
        currentUrl,
        findingsCount: researchResults.findings.length,
        navigationFailures,
        searchResultsCount: searchResults.length,
        contactFound: !!contactInformation,
      });

      const executionPrompt = `Given these research results so far:
${JSON.stringify(researchResults, null, 2)}

${
  searchResults.length > 0
    ? `Recent search results:
${JSON.stringify(searchResults.slice(-5), null, 2)}`
    : ""
}

What should we look into next? Use one of these commands:
- SEARCH: [query] - Search Google with this query
- NAVIGATE: [url] - Visit a webpage
- EXTRACT: [instruction] - Extract specific information
- OBSERVE: [instruction] - Analyze the current page
- CONCLUDE - End research when sufficient information is gathered

Current URL: ${currentUrl}
Contact Information Found: ${contactInformation ? "Yes" : "No"}

IMPORTANT NOTES:
- Prioritize finding contact information if not yet found
- Be creative with search queries to find different kinds of information
- If a URL navigation failed, try a different approach
- For LinkedIn profiles, we can access them (credentials are handled)
- After 3 failed navigation attempts, consider a different strategy
- Focus on finding diverse sources of information

What would you like to do?`;

      const decision = await makeGPTCall(
        [{ role: "user", content: executionPrompt }],
        0.3
      );
      const action = parseAction(decision);

      if (!action) {
        debugLog(
          "research:warning",
          "Failed to parse action, skipping iteration",
          { decision }
        );
        continue;
      }

      if (action.type === "conclude" && !contactInformation) {
        debugLog(
          "research:continue",
          "Cannot conclude without contact information"
        );
        continue;
      }

      if (action.type === "conclude") {
        debugLog("research:conclude", "GPT decided to conclude research");
        break;
      }

      try {
        let result;
        switch (action.type) {
          case "search":
            debugLog("research:search", "Performing Google search", {
              query: action.query,
            });
            searchResults = await searchGoogle(stagehand.page, action.query);
            result = {
              status: "searched",
              query: action.query,
              results: searchResults,
            };
            break;

          case "navigate":
            result = await handleNavigation(
              stagehand,
              linkedIn,
              action,
              profile,
              currentUrl,
              contactInformation
            );
            if (result.contactInfo) {
              contactInformation = result.contactInfo;
            }
            if (result.status === "failed") {
              navigationFailures++;
            }
            break;

          case "extract":
            result = await handleExtraction(stagehand, action);
            break;

          case "observe":
            debugLog("research:observe", "Observing page", {
              instruction: action.instruction,
            });
            result = await stagehand.page.observe({
              instruction: action.instruction,
            });
            debugLog("research:observe-success", "Successfully observed page", {
              result,
            });
            break;
        }

        researchResults.findings.push({
          iteration,
          action: decision,
          result,
        });
      } catch (error) {
        debugLog("research:action-error", "Error executing action", {
          error: error.message,
          stack: error.stack,
          action,
        });
        researchResults.findings.push({
          iteration,
          action: decision,
          error: error.message,
        });
      }

      iteration++;
    }

    const synthesis = await synthesizeResearch(
      researchResults,
      contactInformation
    );

    return {
      profile: synthesis,
      rawResearch: researchResults,
      contactInformation,
    };
  } catch (error) {
    debugLog("research:error", "Fatal error in research process", {
      error: error.message,
      stack: error.stack,
    });
    throw error;
  }
}

async function handleNavigation(
  stagehand,
  linkedIn,
  action,
  profile,
  currentUrl,
  contactInformation
) {
  debugLog("research:navigate", `Attempting to navigate to URL`, {
    url: action.url,
  });
  try {
    if (action.url.includes("linkedin.com")) {
      try {
        await withRetry(() =>  linkedIn.navigateToProfile(action.url, profile));
        const contactInfo = await linkedIn.extractContactInfo();
        return {
          status: "navigated",
          url: action.url,
          contactInfo: contactInfo.contact,
        };
      } catch (error) {
        if (error.message === "Profile does not match target person") {
          debugLog("research:skip", "Skipping non-matching profile", {
            url: action.url,
          });
          return {
            status: "skipped",
            url: action.url,
            reason: "Profile does not match target person",
          };
        }
        throw error;
      }
    } else {
      await stagehand.page.goto(action.url, {
        waitUntil: "networkidle",
        timeout: 30000,
      });
      return { status: "navigated", url: action.url };
    }
  } catch (error) {
    debugLog("research:navigate-error", "Navigation failed", {
      url: action.url,
      error: error.message,
    });
    return {
      status: "failed",
      url: action.url,
      error: error.message,
    };
  }
}

async function handleExtraction(stagehand, action) {
  debugLog("research:extract", "Extracting information", {
    instruction: action.instruction,
  });
  const result = await stagehand.page.extract({
    instruction: action.instruction,
    schema: z.object({
      result: z.string(),
    }),
  });
  debugLog("research:extract-success", "Successfully extracted information", {
    result,
  });
  return result;
}

async function withRetry(fn, maxRetries = 3) {
  for (let attempt = 1; attempt <= maxRetries; attempt++) {
    try {
      return await fn();
    } catch (error) {
      if (attempt === maxRetries) throw error;
      await new Promise((resolve) =>
        setTimeout(resolve, Math.pow(2, attempt) * 1000)
      );
    }
  }
}

async function synthesizeResearch(researchResults, contactInformation) {
  const synthesisPrompt = `Based on all our research:
    ${JSON.stringify(researchResults, null, 2)}
    
    Create a comprehensive profile for this person. Structure it as follows:
    
    ---CONTACT INFORMATION---
    ${contactInformation ? "Found Contact Methods:" : "Best Ways to Reach:"}
    ${
      contactInformation ||
      "No direct contact information found. List available communication channels."
    }
    
    ---PROFESSIONAL PROFILE---
    1. Key findings and insights
    2. Professional background
    3. Interests and activities
    4. Notable achievements or contributions
    5. Sources for each piece of information
    6. Research coverage and gaps
    
    Important Notes:
    - Place ALL contact information at the very top of the profile
    - If certain sources were inaccessible, acknowledge this
    - Focus on successfully retrieved information
    - Maintain a professional tone
    - Include patterns or insights from different sources
    - Note potential areas for further research
    
    Format it in a natural, readable way using Markdown, ensuring contact information is prominently displayed first.`;

  return await makeGPTCall([{ role: "user", content: synthesisPrompt }], 0.7);
}

================
File: src/utils/index.js
================
import { z } from 'zod';
import { debugLog } from './logger.js';

export const parseAction = (actionText) => {
  debugLog("action:parse", "Parsing action text", { actionText });
  try {
    if (actionText.includes("SEARCH")) {
      const query = actionText.match(/SEARCH: (.*)/)[1];
      return { type: "search", query };
    }
    if (actionText.includes("NAVIGATE")) {
      const url = actionText.match(/NAVIGATE: (.*)/)[1];
      return { type: "navigate", url };
    }
    if (actionText.includes("EXTRACT")) {
      const instruction = actionText.match(/EXTRACT: (.*)/)[1];
      return { type: "extract", instruction };
    }
    if (actionText.includes("OBSERVE")) {
      const instruction = actionText.match(/OBSERVE: (.*)/)[1];
      return { type: "observe", instruction };
    }
    if (actionText.includes("CONCLUDE")) {
      return { type: "conclude" };
    }
    return null;
  } catch (error) {
    debugLog("action:parse-error", "Failed to parse action", {
      error: error.message,
    });
    return null;
  }
};



export const ProfileSchema = z.object({
  name: z.string().min(1),
  context: z.string().optional(),
  interests: z.array(z.string()).optional(),
});

================
File: src/utils/logger.js
================
export const debugLog = (category, message, auxiliary = null) => {
  const logLine = {
    timestamp: new Date().toISOString(),
    category,
    message,
    auxiliary: auxiliary && Object.fromEntries(
      Object.entries(auxiliary).map(([k, v]) => [k, {value: v, type: typeof v}])
    )
  };
  console.log(JSON.stringify(logLine));
};

================
File: .cursorrules
================
# Stagehand Project

This is a project that uses Stagehand, which amplifies Playwright with `act`, `extract`, and `observe` added to the Page class.

`Stagehand` is a class that provides config, a `StagehandPage` object via `stagehand.page`, and a `StagehandContext` object via `stagehand.context`.

`Page` is a class that extends the Playwright `Page` class and adds `act`, `extract`, and `observe` methods.
`Context` is a class that extends the Playwright `BrowserContext` class.

Use the following rules to write code for this project.

- When writing Playwright code, wrap it with Stagehand `act`
- When writing code that needs to extract data from the page, use Stagehand `extract`
- When writing code that needs to observe the page, use Stagehand `observe`

## Initialize

```typescript
import { Stagehand } from "@browserbasehq/stagehand";
import StagehandConfig from "./stagehand.config";

const stagehand = new Stagehand(StagehandConfig);
await stagehand.init();

const page = stagehand.page; // Playwright Page with act, extract, and observe methods
const context = stagehand.context; // Playwright BrowserContext
```

## Act

For example, if you are writing Playwright code, wrap it with Stagehand `act` like this:

```typescript
try {
  await page.locator('button[name="Sign in"]').click();
} catch (error) {
  await page.act({
    action: "click the sign in button",
  });
}
```

Act `action` should be as atomic and specific as possible, i.e. "Click the sign in button" or "Type 'hello' into the search input". Avoid actions that are too broad, i.e. "Order me pizza" or "Send an email to Paul asking him to call me". Actions work best for Playwright code that is vulnerable to unexpected DOM changes.

When using `act`, write Playwright code FIRST, then wrap it with a try-catch block where the catch block is `act`.

## Extract

If you are writing code that needs to extract data from the page, use Stagehand `extract` like this:

```typescript
const data = await page.extract({
  instruction: "extract the sign in button text",
  schema: z.object({
    text: z.string(),
  }),
  useTextExtract: true,
});
```

`schema` is a Zod schema that describes the data you want to extract. To extract an array, make sure to pass in a single object that contains the array, as follows:

```typescript
const data = await page.extract({
  instruction: "extract the text inside all buttons",
  schema: z.object({
    text: z.array(z.string()),
  }),
});
```

Set `useTextExtract` to `true` for better results.

## Observe

If you are writing code that needs to observe the page, use Stagehand `observe` like this:

```typescript
const data = await page.observe({
  instruction: "observe the page",
});
```

This returns a list of XPaths and descriptions of the data you want to extract as `{ selector: string; description: string }[]`.

================
File: .env.example
================
BROWSERBASE_PROJECT_ID="YOUR_BROWSERBASE_PROJECT_ID"
BROWSERBASE_API_KEY="YOUR_BROWSERBASE_API_KEY"
OPENAI_API_KEY="THIS_IS_OPTIONAL_WITH_ANTHROPIC_KEY"
ANTHROPIC_API_KEY="THIS_IS_OPTIONAL_WITH_OPENAI_KEY"

================
File: .gitignore
================
.env
node_modules
tmp
downloads
.DS_Store
dist

================
File: .repomixignore
================
tsconfig.json
package.json
package-lock.json

================
File: deploy.sh
================
cd $FORGE_SITE_PATH
npm install
npm run build
pm2 reload browser-service || pm2 start server.js --name browser-service

================
File: ecosystem.config.js
================
export default {
    apps: [{
      name: 'browser-service',
      script: 'server.js',
      exec_mode: 'fork',
      instances: 1,
      autorestart: true,
      watch: false,
      max_memory_restart: '1G',
      env: {
        NODE_ENV: 'production',
      }
    }]
  }

================
File: example-run.js
================
// example-usage.js
import { Stagehand } from "@browserbasehq/stagehand";
import { StagehandConfig } from './config/index.js';
import { LinkedInService } from './services/linkedInService.js';
import { searchGoogleWithRetry } from './services/googleService.js';
import { makeGPTCall, promptTemplates } from './services/openaiService.js';
import { debugLog } from './utils/index.js';

async function runExample() {
  // Initialize Stagehand
  const stagehand = new Stagehand(StagehandConfig);
  await stagehand.init();

  try {
    // Example profile to research
    const profile = {
      name: "Emi Laughton",
      context: "Head of Marketing",
      interests: ["brand strategy"]
    };

    // 1. Start with Google search
    console.log("Starting Google search...");
    const searchQuery = `${profile.name} ${profile.context} linkedin`;
    const searchResults = await searchGoogleWithRetry(stagehand.page, searchQuery);
    
    // Find LinkedIn profile URL from search results
    const linkedInUrl = searchResults.find(result => 
      result.url.includes('linkedin.com/in/'))?.url;

    if (linkedInUrl) {
      // 2. Initialize LinkedIn service and navigate to profile
      console.log("LinkedIn profile found, extracting information...");
      const linkedIn = new LinkedInService(stagehand);
      
      try {
        await linkedIn.navigateToProfile(linkedInUrl, profile);
        
        // 3. Extract contact information
        const contactInfo = await linkedIn.extractContactInfo();
        console.log("Contact information:", contactInfo);

        // 4. Use GPT to analyze findings
        const research = {
          linkedInProfile: linkedInUrl,
          contactInfo: contactInfo.contact,
          searchResults: searchResults
        };

        const analysis = await makeGPTCall([{
          role: "user",
          content: promptTemplates.synthesizeFindings(research, contactInfo.contact)
        }]);

        console.log("\nResearch Analysis:");
        console.log(analysis);

      } catch (error) {
        if (error.message === 'Profile does not match target person') {
          console.log("Found LinkedIn profile was not the correct person");
        } else {
          throw error;
        }
      }
    } else {
      console.log("No LinkedIn profile found in search results");
    }

  } catch (error) {
    console.error("Error during research:", error);
  } finally {
    await stagehand.close();
  }
}

// Run the example
runExample().catch(console.error);

================
File: index.ts
================
/**
 * ðŸ¤˜ Welcome to Stagehand!
 *
 * You probably DON'T NEED TO BE IN THIS FILE
 *
 * You're probably instead looking for the main() function in main.ts
 *
 * This is run when you do npm run start; it just calls main()
 *
 */

import { Stagehand } from "@browserbasehq/stagehand";
import StagehandConfig from "./stagehand.config.js";
import chalk from "chalk";
import { main } from "./main.js";
import boxen from "boxen";

async function run() {
  const stagehand = new Stagehand({
    ...StagehandConfig,
  });
  await stagehand.init();

  if (StagehandConfig.env === "BROWSERBASE" && stagehand.browserbaseSessionID) {
    console.log(
      boxen(
        `View this session live in your browser: \n${chalk.blue(
          `https://browserbase.com/sessions/${stagehand.browserbaseSessionID}`
        )}`,
        {
          title: "Browserbase",
          padding: 1,
          margin: 3,
        }
      )
    );
  }

  const page = stagehand.page;
  const context = stagehand.context;
  await main({
    page,
    context,
    stagehand,
  });
  await stagehand.close();
  console.log(
    `\nðŸ¤˜ Thanks for using Stagehand! Create an issue if you have any feedback: ${chalk.blue(
      "https://github.com/browserbase/stagehand/issues/new"
    )}\n`
  );
}

run();

================
File: main.ts
================
/**
 * ðŸ¤˜ Welcome to Stagehand!
 *
 * TO RUN THIS PROJECT:
 * ```
 * npm install
 * npm run start
 * ```
 *
 * To edit config, see `stagehand.config.ts`
 *
 * In this quickstart, we'll be automating a browser session to show you the power of Playwright and Stagehand's AI features.
 *
 * 1. Go to https://docs.browserbase.com/
 * 2. Use `extract` to find information about the quickstart
 * 3. Use `observe` to find the links under the 'Guides' section
 * 4. Use Playwright to click the first link. If it fails, use `act` to gracefully fallback to Stagehand AI.
 */

import { Page, BrowserContext, Stagehand } from "@browserbasehq/stagehand";
import { z } from "zod";
import chalk from "chalk";
import boxen from "boxen";
import dotenv from "dotenv";

dotenv.config();

export async function main({
  page,
  context,
  stagehand,
}: {
  page: Page; // Playwright Page with act, extract, and observe methods
  context: BrowserContext; // Playwright BrowserContext
  stagehand: Stagehand; // Stagehand instance
}) {
  console.log(
    [
      `ðŸ¤˜ ${chalk.yellow("Welcome to Stagehand!")}`,
      "",
      "Stagehand is a tool that allows you to automate browser interactions.",
      "Watch as this demo automatically performs the following steps:",
      "",
      `ðŸ“ Step 1: Stagehand will auto-navigate to ${chalk.blue(
        "https://docs.browserbase.com/"
      )}`,
      `ðŸ“ Step 2: Stagehand will use AI to ${chalk.green(
        "extract"
      )} information about the quickstart`,
      `ðŸ“ Step 3: Stagehand will use AI to ${chalk.green(
        "observe"
      )} and identify links in the 'Guides' section`,
      `ðŸ“ Step 4: Stagehand will attempt to click the first link using Playwright, with ${chalk.green(
        "act"
      )} as an AI fallback`,
    ].join("\n")
  );

  //   You can use the `page` instance to write any Playwright code
  //   For more info: https://playwright.dev/docs/pom
  await page.goto("https://docs.browserbase.com/");

  const description = await page.extract({
    instruction: "extract the title, description, and link of the quickstart",
    // Zod is a schema validation library similar to Pydantic in Python
    // For more information on Zod, visit: https://zod.dev/
    schema: z.object({
      title: z.string(),
      link: z.string(),
      description: z.string(),
    }),
  });
  announce(
    `The ${chalk.bgYellow(description.title)} is at: ${chalk.bgYellow(
      chalk.blue(description.link)
    )}` +
      `\n\n${chalk.bgYellow(description.description)}` +
      `\n\n${chalk.gray(JSON.stringify(description, null, 2))}`,
    "Extract"
  );

  const observeResult = await page.observe({
    instruction: "Find the links under the 'Guides' section",
  });
  announce(
    `${chalk.green("Observe:")} We can click:\n${observeResult
      .map(
        (r) => `"${chalk.yellow(r.description)}" -> ${chalk.gray(r.selector)}`
      )
      .join("\n")}`,
    "Observe"
  );

  //   In the event that your Playwright code fails, you can use the `act` method to
  //   let Stagehand AI take over and complete the action.
  try {
    throw new Error(
      "Comment out line 118 in index.ts to run the base Playwright code!"
    );

    // Wait for search button and click it
    const quickStartSelector = `#content-area > div.relative.mt-8.prose.prose-gray.dark\:prose-invert > div > a:nth-child(1)`;
    await page.waitForSelector(quickStartSelector);
    await page.locator(quickStartSelector).click();
    await page.waitForLoadState("networkidle");
    announce(
      `Clicked the quickstart link using base Playwright code. ${chalk.yellow(
        "Uncomment line 118 in index.ts to have Stagehand take over!"
      )}`
    );
  } catch (e) {
    if (!(e instanceof Error)) {
      throw e;
    }
    announce(
      `${chalk.red(
        "Looks like an error occurred running Playwright. Let's have Stagehand take over!"
      )} \n${chalk.gray(e.message)}`,
      "Playwright"
    );

    const actResult = await page.act({
      action: "Click the link to the quickstart",
    });
    announce(
      `${chalk.green(
        "Clicked the quickstart link using Stagehand AI fallback."
      )} \n${chalk.gray(actResult)}`,
      "Act"
    );
  }

  //   Close the browser
  await stagehand.close();

  console.log(
    [
      "To recap, here are the steps we took:",
      `1. We went to ${chalk.blue("https://docs.browserbase.com/")}`,
      `---`,
      `2. We used ${chalk.green(
        "extract"
      )} to find information about the quickstart`,
      `The ${chalk.bgYellow(description.title)} is at: ${chalk.bgYellow(
        chalk.blue(description.link)
      )}` +
        `\n\n${chalk.bgYellow(description.description)}` +
        `\n\n${chalk.gray(JSON.stringify(description, null, 2))}`,
      `---`,
      `3. We used ${chalk.green(
        "observe"
      )} to find the links under the 'Guides' section and got the following results:`,
      `\nWe could have clicked:\n${observeResult
        .map(
          (r) => `"${chalk.yellow(r.description)}" -> ${chalk.gray(r.selector)}`
        )
        .join("\n")}`,
      `---`,
      `4. We used Playwright to click the first link. If it failed, we used ${chalk.green(
        "act"
      )} to gracefully fallback to Stagehand AI.`,
    ].join("\n\n")
  );
}

function announce(message: string, title?: string) {
  console.log(
    boxen(message, {
      padding: 1,
      margin: 3,
      title: title || "Stagehand",
    })
  );
}

================
File: README.md
================
# ðŸ¤˜ Welcome to Stagehand!

Hey! This is a project built with [Stagehand](https://github.com/browserbase/stagehand).

You can build your own web agent using: `npx create-browser-app`!

## Setting the Stage

Stagehand is an SDK for automating browsers. It's built on top of [Playwright](https://playwright.dev/) and provides a higher-level API for better debugging and AI fail-safes.

## Curtain Call

Get ready for a show-stopping development experience. Just run:

```bash
npm install && npm start
```

## What's Next?

### Add your API keys

Required API keys/environment variables are in the `.env.example` file. Copy it to `.env` and add your API keys.

```bash
cp .env.example .env && nano .env # Add your API keys to .env
```

### Custom .cursorrules

We have custom .cursorrules for this project. It'll help quite a bit with writing Stagehand easily.

### Run on Browserbase

To run on Browserbase, add your API keys to .env and change `env: "LOCAL"` to `env: "BROWSERBASE"` in [stagehand.config.ts](stagehand.config.ts).

### Use Anthropic Claude 3.5 Sonnet

1. Add your API key to .env
2. Change `modelName: "gpt-4o"` to `modelName: "claude-3-5-sonnet-latest"` in [stagehand.config.ts](stagehand.config.ts)
3. Change `modelClientOptions: { apiKey: process.env.OPENAI_API_KEY }` to `modelClientOptions: { apiKey: process.env.ANTHROPIC_API_KEY }` in [stagehand.config.ts](stagehand.config.ts)

================
File: server.js
================
// server.js
// Load environment variables first, before any other imports
import { StagehandConfig, serverConfig } from "./src/config/index.js";

import express from "express";
import { Stagehand } from "@browserbasehq/stagehand";
import Queue from "bull";
import rateLimit from "express-rate-limit";
import { z } from "zod";
import pkg from "@bull-monitor/express";
import rootPkg from "@bull-monitor/root/dist/bull-adapter.js";
import { conductResearch } from "./src/services/researchService.js";
import { debugLog } from "./src/utils/logger.js";
import { ProfileSchema } from "./src/utils/index.js";

const { BullMonitorExpress } = pkg;
const { BullAdapter } = rootPkg;

// Initialize Express
const app = express();
app.use(express.json());

// Rate limiting
const limiter = rateLimit({
  windowMs: 15 * 60 * 1000,
  max: 100,
});

app.use("/research", limiter);

// Initialize Bull Queue
const researchQueue = new Queue("research-queue", serverConfig.redisUrl, {
  defaultJobOptions: {
    timeout: 1800000, // 30 minute timeout
    attempts: 1,
    backoff: {
      type: "exponential",
      delay: 2000,
    },
    removeOnComplete: 100,
    removeOnFail: 100,
  },
});

// Setup Bull Monitor
async function setupMonitor() {
  const monitor = new BullMonitorExpress({
    queues: [new BullAdapter(researchQueue)],
  });
  await monitor.init();
  app.use("/monitor", monitor.router);
}

setupMonitor().catch(console.error);

// Express routes
app.post("/research", async (req, res) => {
  try {
    const profile = ProfileSchema.parse(req.body);
    const job = await researchQueue.add(profile);

    res.status(202).json({
      jobId: job.id,
      status: "processing",
      statusUrl: `/research/${job.id}`,
    });
  } catch (error) {
    if (error instanceof z.ZodError) {
      return res
        .status(400)
        .json({ error: "Invalid input", details: error.errors });
    }
    res.status(400).json({ error: error.message });
  }
});

app.get("/research/:jobId", async (req, res) => {
  try {
    const job = await researchQueue.getJob(req.params.jobId);
    if (!job) {
      return res.status(404).json({ error: "Job not found" });
    }

    const state = await job.getState();

    res.json({
      jobId: job.id,
      status: state,
      progress: job.progress(),
      result: job.returnvalue,
      error: job.failedReason,
      timestamp: {
        created: job.timestamp,
        started: job.processedOn,
        finished: job.finishedOn,
      },
    });
  } catch (error) {
    res.status(500).json({ error: error.message });
  }
});

// Queue processor
researchQueue.process(async (job) => {
  const stagehand = new Stagehand(StagehandConfig);

  try {
    await stagehand.init();
    return await conductResearch(stagehand, job.data);
  } finally {
    await stagehand.close();
  }
});

researchQueue.on("stalled", async (job) => {
  debugLog("queue:stalled", `Job ${job.id} stalled`, {
    jobData: job.data,
    timestamp: new Date().toISOString(),
  });
  await job.moveToFailed({ message: "Job stalled" });
});

// Add cleanup
const cleanupInterval = setInterval(async () => {
  await researchQueue.clean(7 * 24 * 3600 * 1000, "completed");
  await researchQueue.clean(7 * 24 * 3600 * 1000, "failed");
}, 24 * 3600 * 1000);

researchQueue.on('failed', async (job, err) => {
  const recoveryStrategies = {
    'Navigation timeout': async () => {
      await job.retry({ delay: 30000 });
    },
    'Profile not found': async () => {
      job.data.alternateStrategy = true;
      await job.retry();
    }
  };

  const strategy = Object.entries(recoveryStrategies)
    .find(([error]) => err.message.includes(error))?.[1];
    
  if (strategy) await strategy();
});

// Error handling
app.use((err, req, res, next) => {
  console.error(err.stack);
  res.status(500).json({
    error: "Internal server error",
    message: serverConfig.env === "development" ? err.message : undefined,
  });
});

// Queue event handling
researchQueue.on("completed", (job, result) => {
  debugLog("queue:completed", `Job ${job.id} completed successfully`);
});

researchQueue.on("failed", (job, error) => {
  debugLog("queue:failed", `Job ${job.id} failed`, { error: error.message });
});

researchQueue.on("stalled", (job) => {
  debugLog("queue:stalled", `Job ${job.id} stalled`);
});

// Start server
app.listen(serverConfig.port, serverConfig.host, () => {
  console.log(
    `Research server running on ${serverConfig.host}:${serverConfig.port}`
  );
});

================
File: stagehand.config.ts
================
import type { ConstructorParams, LogLine } from "@browserbasehq/stagehand";
import dotenv from "dotenv";

dotenv.config();

const StagehandConfig: ConstructorParams = {
  env: "LOCAL",
  apiKey: process.env.BROWSERBASE_API_KEY /* API key for authentication */,
  projectId: process.env.BROWSERBASE_PROJECT_ID /* Project identifier */,
  debugDom: true /* Enable DOM debugging features */,
  headless: true /* Run browser in headless mode */,
  logger: (message: LogLine) =>
    console.log(logLineToString(message)) /* Custom logging function */,
  domSettleTimeoutMs: 30_000 /* Timeout for DOM to settle in milliseconds */,
  browserbaseSessionCreateParams: {
    projectId: process.env.BROWSERBASE_PROJECT_ID!,
  },
  enableCaching: true /* Enable caching functionality */,
  browserbaseSessionID:
    undefined /* Session ID for resuming Browserbase sessions */,
  modelName: "gpt-4o" /* Name of the model to use */,
	modelClientOptions: {
    apiKey: process.env.OPENAI_API_KEY,
  } /* Configuration options for the model client */,
};

export default StagehandConfig;

/**
 * Custom logging function that you can use to filter logs.
 *
 * General pattern here is that `message` will always be unique with no params
 * Any param you would put in a log is in `auxiliary`.
 *
 * For example, an error log looks like this:
 *
 * ```
 * {
 *   category: "error",
 *   message: "Some specific error occurred",
 *   auxiliary: {
 *     message: { value: "Error message", type: "string" },
 *     trace: { value: "Error trace", type: "string" }
 *   }
 * }
 * ```
 *
 * You can then use `logLineToString` to filter for a specific log pattern like
 *
 * ```
 * if (logLine.message === "Some specific error occurred") {
 *   console.log(logLineToString(logLine));
 * }
 * ```
 */
export function logLineToString(logLine: LogLine): string {
  // If you want more detail, set this to false. However, this will make the logs
  // more verbose and harder to read.
  const HIDE_AUXILIARY = true;

  try {
    const timestamp = logLine.timestamp || new Date().toISOString();
    if (logLine.auxiliary?.error) {
      return `${timestamp}::[stagehand:${logLine.category}] ${logLine.message}\n ${logLine.auxiliary.error.value}\n ${logLine.auxiliary.trace.value}`;
    }

    // If we want to hide auxiliary information, we don't add it to the log
    return `${timestamp}::[stagehand:${logLine.category}] ${logLine.message} ${
      logLine.auxiliary && !HIDE_AUXILIARY
        ? JSON.stringify(logLine.auxiliary)
        : ""
    }`;
  } catch (error) {
    console.error(`Error logging line:`, error);
    return "error logging line";
  }
}

================
File: test.sh
================
curl -X POST http://localhost:3333/browser \
  -H "Content-Type: application/json" \
  -d '{
    "url": "https://stuartmason.co.uk",
    "action": "click the about page link",
    "extract": "get all the content from the page"
}'


curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Iggy Hammick",
    "context": "Designer, founder of dark blue"
  }'

curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Ben Lipscombe",
    "context": "UK Based PPC Specialist"
  }'

  curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Ali Gallop",
    "context": "Video Producer, founder of theres this place"
  }'

  curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Daniel Ruffles",
    "context": "UK based brand and design expert"
  }'


  curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Stu Mason",
    "context": "UK based web developer"
  }'


    curl -X POST http://localhost:3333/research \
  -H "Content-Type: application/json" \
  -d '{
    "name": "Emi Laughton",
    "context": "Aviva Marketing Lead"
  }'

================
File: utils.ts
================
import boxen from "boxen";
import { z } from "zod";
export function announce(message: string, title?: string) {
  console.log(
    boxen(message, {
      padding: 1,
      margin: 3,
      title: title || "Stagehand",
    })
  );
}

/**
 * Get an environment variable and throw an error if it's not found
 * @param name - The name of the environment variable
 * @returns The value of the environment variable
 */
export function getEnvVar(name: string, required = true): string | undefined {
  const value = process.env[name];
  if (!value && required) {
    throw new Error(`${name} not found in environment variables`);
  }
  return value;
}

/**
 * Validate a Zod schema against some data
 * @param schema - The Zod schema to validate against
 * @param data - The data to validate
 * @returns Whether the data is valid against the schema
 */
export function validateZodSchema(schema: z.ZodTypeAny, data: unknown) {
  try {
    schema.parse(data);
    return true;
  } catch {
    return false;
  }
}
